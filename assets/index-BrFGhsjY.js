import{S as Qt}from"./index-BOvYCoiN.js";import{a1 as Xt}from"./index-BfYWPPsp.js";import{r as Kt,c as Wt}from"./rdf-editor-BIh2fq8w.js";import{r as Ct}from"./canonicalize-53SzByLi.js";var ye={},me,it;function Ze(){return it||(it=1,me=class Pt{constructor(r,p=new Map,y=0){this.prefix=r,this._existing=p,this.counter=y}clone(){const{prefix:r,_existing:p,counter:y}=this;return new Pt(r,new Map(p),y)}getId(r){const p=r&&this._existing.get(r);if(p)return p;const y=this.prefix+this.counter;return this.counter++,r&&this._existing.set(r,y),y}hasId(r){return this._existing.has(r)}getOldIds(){return[...this._existing.keys()]}}),me}var ve={},st;function Yt(){return st||(st=1,function(v,r){if(v.setImmediate)return;var p=1,y={},k=!1,i=v.document,t;function n(T){typeof T!="function"&&(T=new Function(""+T));for(var f=new Array(arguments.length-1),e=0;e<f.length;e++)f[e]=arguments[e+1];var s={callback:T,args:f};return y[p]=s,t(p),p++}function a(T){delete y[T]}function b(T){var f=T.callback,e=T.args;switch(e.length){case 0:f();break;case 1:f(e[0]);break;case 2:f(e[0],e[1]);break;case 3:f(e[0],e[1],e[2]);break;default:f.apply(r,e);break}}function I(T){if(k)setTimeout(I,0,T);else{var f=y[T];if(f){k=!0;try{b(f)}finally{a(T),k=!1}}}}function D(){t=function(T){process.nextTick(function(){I(T)})}}function d(){if(v.postMessage&&!v.importScripts){var T=!0,f=v.onmessage;return v.onmessage=function(){T=!1},v.postMessage("","*"),v.onmessage=f,T}}function l(){var T="setImmediate$"+Math.random()+"$",f=function(e){e.source===v&&typeof e.data=="string"&&e.data.indexOf(T)===0&&I(+e.data.slice(T.length))};v.addEventListener?v.addEventListener("message",f,!1):v.attachEvent("onmessage",f),t=function(e){v.postMessage(T+e,"*")}}function w(){var T=new MessageChannel;T.port1.onmessage=function(f){var e=f.data;I(e)},t=function(f){T.port2.postMessage(f)}}function j(){var T=i.documentElement;t=function(f){var e=i.createElement("script");e.onreadystatechange=function(){I(f),e.onreadystatechange=null,T.removeChild(e),e=null},T.appendChild(e)}}function O(){t=function(T){setTimeout(I,0,T)}}var H=Object.getPrototypeOf&&Object.getPrototypeOf(v);H=H&&H.setTimeout?H:v,{}.toString.call(v.process)==="[object process]"?D():d()?l():v.MessageChannel?w():i&&"onreadystatechange"in i.createElement("script")?j():O(),H.setImmediate=n,H.clearImmediate=a}(typeof self>"u"?typeof window>"u"?ve:window:self)),ve}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var be,at;function fe(){if(at)return be;at=1,Yt();const v=self.crypto||self.msCrypto;return be=class{constructor(p){if(!(v&&v.subtle))throw new Error("crypto.subtle not found.");if(p==="sha256")this.algorithm={name:"SHA-256"};else if(p==="sha1")this.algorithm={name:"SHA-1"};else throw new Error(`Unsupported algorithm "${p}".`);this._content=""}update(p){this._content+=p}async digest(){const p=new TextEncoder().encode(this._content),y=new Uint8Array(await v.subtle.digest(this.algorithm,p));let k="";for(let i=0;i<y.length;++i)k+=y[i].toString(16).padStart(2,"0");return k}},be}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var we,ot;function Bt(){return ot||(ot=1,we=class{constructor(r){this.current=r.sort(),this.done=!1,this.dir=new Map;for(let p=0;p<r.length;++p)this.dir.set(r[p],!0)}hasNext(){return!this.done}next(){const{current:r,dir:p}=this,y=r.slice();let k=null,i=0;const t=r.length;for(let n=0;n<t;++n){const a=r[n],b=p.get(a);(k===null||a>k)&&(b&&n>0&&a>r[n-1]||!b&&n<t-1&&a>r[n+1])&&(k=a,i=n)}if(k===null)this.done=!0;else{const n=p.get(k)?i-1:i+1;r[i]=r[n],r[n]=k;for(const a of r)a>k&&p.set(a,!p.get(a))}return y}}),we}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var xe,lt;function et(){if(lt)return xe;lt=1;const r="http://www.w3.org/1999/02/22-rdf-syntax-ns#"+"langString",p="http://www.w3.org/2001/XMLSchema#string",y="NamedNode",k="BlankNode",i="Literal",t="DefaultGraph",n={};(()=>{const l="(?:<([^:]+:[^>]*)>)",j="A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�"+"_",O=j+"0-9-·̀-ͯ‿-⁀",T="(_:(?:["+j+"0-9])(?:(?:["+O+".])*(?:["+O+"]))?)",f='"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"',e="(?:\\^\\^"+l+")",c="(?:"+f+"(?:"+e+"|"+"(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))"+")?)",_="[ \\t]+",u="[ \\t]*",N="(?:"+l+"|"+T+")"+_,m=l+_,J="(?:"+l+"|"+T+"|"+c+")"+u,M="(?:\\.|(?:(?:"+l+"|"+T+")"+u+"\\.))";n.eoln=/(?:\r\n)|(?:\n)|(?:\r)/g,n.empty=new RegExp("^"+u+"$"),n.quad=new RegExp("^"+u+N+m+J+M+u+"$")})(),xe=class de{static parse(w){const j=[],O={},H=w.split(n.eoln);let T=0;for(const f of H){if(T++,n.empty.test(f))continue;const e=f.match(n.quad);if(e===null)throw new Error("N-Quads parse error on line "+T+".");const s={subject:null,predicate:null,object:null,graph:null};if(e[1]!==void 0?s.subject={termType:y,value:e[1]}:s.subject={termType:k,value:e[2]},s.predicate={termType:y,value:e[3]},e[4]!==void 0?s.object={termType:y,value:e[4]}:e[5]!==void 0?s.object={termType:k,value:e[5]}:(s.object={termType:i,value:void 0,datatype:{termType:y}},e[7]!==void 0?s.object.datatype.value=e[7]:e[8]!==void 0?(s.object.datatype.value=r,s.object.language=e[8]):s.object.datatype.value=p,s.object.value=d(e[6])),e[9]!==void 0?s.graph={termType:y,value:e[9]}:e[10]!==void 0?s.graph={termType:k,value:e[10]}:s.graph={termType:t,value:""},!(s.graph.value in O))O[s.graph.value]=[s],j.push(s);else{let c=!0;const _=O[s.graph.value];for(const u of _)if(a(u,s)){c=!1;break}c&&(_.push(s),j.push(s))}}return j}static serialize(w){Array.isArray(w)||(w=de.legacyDatasetToQuads(w));const j=[];for(const O of w)j.push(de.serializeQuad(O));return j.sort().join("")}static serializeQuadComponents(w,j,O,H){let T="";return w.termType===y?T+=`<${w.value}>`:T+=`${w.value}`,T+=` <${j.value}> `,O.termType===y?T+=`<${O.value}>`:O.termType===k?T+=O.value:(T+=`"${I(O.value)}"`,O.datatype.value===r?O.language&&(T+=`@${O.language}`):O.datatype.value!==p&&(T+=`^^<${O.datatype.value}>`)),H.termType===y?T+=` <${H.value}>`:H.termType===k&&(T+=` ${H.value}`),T+=` .
`,T}static serializeQuad(w){return de.serializeQuadComponents(w.subject,w.predicate,w.object,w.graph)}static legacyDatasetToQuads(w){const j=[],O={"blank node":k,IRI:y,literal:i};for(const H in w)w[H].forEach(f=>{const e={};for(const s in f){const c=f[s],_={termType:O[c.type],value:c.value};_.termType===i&&(_.datatype={termType:y},"datatype"in c&&(_.datatype.value=c.datatype),"language"in c?("datatype"in c||(_.datatype.value=r),_.language=c.language):"datatype"in c||(_.datatype.value=p)),e[s]=_}H==="@default"?e.graph={termType:t,value:""}:e.graph={termType:H.startsWith("_:")?k:y,value:H},j.push(e)});return j}};function a(l,w){return!(l.subject.termType===w.subject.termType&&l.object.termType===w.object.termType)||!(l.subject.value===w.subject.value&&l.predicate.value===w.predicate.value&&l.object.value===w.object.value)?!1:l.object.termType!==i?!0:l.object.datatype.termType===w.object.datatype.termType&&l.object.language===w.object.language&&l.object.datatype.value===w.object.datatype.value}const b=/["\\\n\r]/g;function I(l){return l.replace(b,function(w){switch(w){case'"':return'\\"';case"\\":return"\\\\";case`
`:return"\\n";case"\r":return"\\r"}})}const D=/(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;function d(l){return l.replace(D,function(w,j,O,H){if(j)switch(j){case"t":return"	";case"b":return"\b";case"n":return`
`;case"r":return"\r";case"f":return"\f";case'"':return'"';case"'":return"'";case"\\":return"\\"}if(O)return String.fromCharCode(parseInt(O,16));if(H)throw new Error("Unsupported U escape")})}return xe}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var Ie,ct;function Vt(){if(ct)return Ie;ct=1;const v=Ze(),r=fe(),p=Bt(),y=et();Ie=class{constructor({createMessageDigest:t=()=>new r("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:a=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new v("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=a,this.quads=null,this.deepIterations=null}async main(t){this.deepIterations=new Map,this.quads=t;for(const l of t)this._addBlankNodeQuadInfo({quad:l,component:l.subject}),this._addBlankNodeQuadInfo({quad:l,component:l.object}),this._addBlankNodeQuadInfo({quad:l,component:l.graph});const n=new Map,a=[...this.blankNodeInfo.keys()];let b=0;for(const l of a)++b%100===0&&await this._yield(),await this._hashAndTrackBlankNode({id:l,hashToBlankNodes:n});const I=[...n.keys()].sort(),D=[];for(const l of I){const w=n.get(l);if(w.length>1){D.push(w);continue}const j=w[0];this.canonicalIssuer.getId(j)}for(const l of D){const w=[];for(const j of l){if(this.canonicalIssuer.hasId(j))continue;const O=new v("_:b");O.getId(j);const H=await this.hashNDegreeQuads(j,O);w.push(H)}w.sort(k);for(const j of w){const O=j.issuer.getOldIds();for(const H of O)this.canonicalIssuer.getId(H)}}const d=[];for(const l of this.quads){const w=y.serializeQuadComponents(this._componentWithCanonicalId(l.subject),l.predicate,this._componentWithCanonicalId(l.object),this._componentWithCanonicalId(l.graph));d.push(w)}return d.sort(),d.join("")}async hashFirstDegreeQuads(t){const n=[],a=this.blankNodeInfo.get(t),b=a.quads;for(const D of b){const d={subject:null,predicate:D.predicate,object:null,graph:null};d.subject=this.modifyFirstDegreeComponent(t,D.subject,"subject"),d.object=this.modifyFirstDegreeComponent(t,D.object,"object"),d.graph=this.modifyFirstDegreeComponent(t,D.graph,"graph"),n.push(y.serializeQuad(d))}n.sort();const I=this.createMessageDigest();for(const D of n)I.update(D);return a.hash=await I.digest(),a.hash}async hashRelatedBlankNode(t,n,a,b){let I;this.canonicalIssuer.hasId(t)?I=this.canonicalIssuer.getId(t):a.hasId(t)?I=a.getId(t):I=this.blankNodeInfo.get(t).hash;const D=this.createMessageDigest();return D.update(b),b!=="g"&&D.update(this.getRelatedPredicate(n)),D.update(I),D.digest()}async hashNDegreeQuads(t,n){const a=this.deepIterations.get(t)||0;if(a>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,a+1);const b=this.createMessageDigest(),I=await this.createHashToRelated(t,n),D=[...I.keys()].sort();for(const d of D){b.update(d);let l="",w;const j=new p(I.get(d));let O=0;for(;j.hasNext();){const H=j.next();++O%3===0&&await this._yield();let T=n.clone(),f="";const e=[];let s=!1;for(const c of H)if(this.canonicalIssuer.hasId(c)?f+=this.canonicalIssuer.getId(c):(T.hasId(c)||e.push(c),f+=T.getId(c)),l.length!==0&&f>l){s=!0;break}if(!s){for(const c of e){const _=await this.hashNDegreeQuads(c,T);if(f+=T.getId(c),f+=`<${_.hash}>`,T=_.issuer,l.length!==0&&f>l){s=!0;break}}s||(l.length===0||f<l)&&(l=f,w=T)}}b.update(l),n=w}return{hash:await b.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}async createHashToRelated(t,n){const a=new Map,b=this.blankNodeInfo.get(t).quads;let I=0;for(const D of b)++I%100===0&&await this._yield(),await Promise.all([this._addRelatedBlankNodeHash({quad:D,component:D.subject,position:"s",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:D,component:D.object,position:"o",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:D,component:D.graph,position:"g",id:t,issuer:n,hashToRelated:a})]);return a}async _hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const a=await this.hashFirstDegreeQuads(t),b=n.get(a);b?b.push(t):n.set(a,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const a=n.value,b=this.blankNodeInfo.get(a);b?b.quads.add(t):this.blankNodeInfo.set(a,{quads:new Set([t]),hash:null})}async _addRelatedBlankNodeHash({quad:t,component:n,position:a,id:b,issuer:I,hashToRelated:D}){if(!(n.termType==="BlankNode"&&n.value!==b))return;const d=n.value,l=await this.hashRelatedBlankNode(d,t,I,a),w=D.get(l);w?w.push(d):D.set(l,[d])}_componentWithCanonicalId(t){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}async _yield(){return new Promise(t=>setImmediate(t))}};function k(i,t){return i.hash<t.hash?-1:i.hash>t.hash?1:0}return Ie}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var Ne,ut;function Zt(){if(ut)return Ne;ut=1;const v=fe(),r=Vt();return Ne=class extends r{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new v("sha1")}modifyFirstDegreeComponent(y,k,i){return k.termType!=="BlankNode"?k:i==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:k.value===y?"_:a":"_:z"}}getRelatedPredicate(y){return y.predicate.value}async createHashToRelated(y,k){const i=new Map,t=this.blankNodeInfo.get(y).quads;let n=0;for(const a of t){let b,I;if(a.subject.termType==="BlankNode"&&a.subject.value!==y)I=a.subject.value,b="p";else if(a.object.termType==="BlankNode"&&a.object.value!==y)I=a.object.value,b="r";else continue;++n%100===0&&await this._yield();const D=await this.hashRelatedBlankNode(I,a,k,b),d=i.get(D);d?d.push(I):i.set(D,[I])}return i}},Ne}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var Ee,dt;function Gt(){if(dt)return Ee;dt=1;const v=Ze(),r=fe(),p=Bt(),y=et();Ee=class{constructor({createMessageDigest:t=()=>new r("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:a=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new v("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=a,this.quads=null,this.deepIterations=null}main(t){this.deepIterations=new Map,this.quads=t;for(const d of t)this._addBlankNodeQuadInfo({quad:d,component:d.subject}),this._addBlankNodeQuadInfo({quad:d,component:d.object}),this._addBlankNodeQuadInfo({quad:d,component:d.graph});const n=new Map,a=[...this.blankNodeInfo.keys()];for(const d of a)this._hashAndTrackBlankNode({id:d,hashToBlankNodes:n});const b=[...n.keys()].sort(),I=[];for(const d of b){const l=n.get(d);if(l.length>1){I.push(l);continue}const w=l[0];this.canonicalIssuer.getId(w)}for(const d of I){const l=[];for(const w of d){if(this.canonicalIssuer.hasId(w))continue;const j=new v("_:b");j.getId(w);const O=this.hashNDegreeQuads(w,j);l.push(O)}l.sort(k);for(const w of l){const j=w.issuer.getOldIds();for(const O of j)this.canonicalIssuer.getId(O)}}const D=[];for(const d of this.quads){const l=y.serializeQuadComponents(this._componentWithCanonicalId({component:d.subject}),d.predicate,this._componentWithCanonicalId({component:d.object}),this._componentWithCanonicalId({component:d.graph}));D.push(l)}return D.sort(),D.join("")}hashFirstDegreeQuads(t){const n=[],a=this.blankNodeInfo.get(t),b=a.quads;for(const D of b){const d={subject:null,predicate:D.predicate,object:null,graph:null};d.subject=this.modifyFirstDegreeComponent(t,D.subject,"subject"),d.object=this.modifyFirstDegreeComponent(t,D.object,"object"),d.graph=this.modifyFirstDegreeComponent(t,D.graph,"graph"),n.push(y.serializeQuad(d))}n.sort();const I=this.createMessageDigest();for(const D of n)I.update(D);return a.hash=I.digest(),a.hash}hashRelatedBlankNode(t,n,a,b){let I;this.canonicalIssuer.hasId(t)?I=this.canonicalIssuer.getId(t):a.hasId(t)?I=a.getId(t):I=this.blankNodeInfo.get(t).hash;const D=this.createMessageDigest();return D.update(b),b!=="g"&&D.update(this.getRelatedPredicate(n)),D.update(I),D.digest()}hashNDegreeQuads(t,n){const a=this.deepIterations.get(t)||0;if(a>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,a+1);const b=this.createMessageDigest(),I=this.createHashToRelated(t,n),D=[...I.keys()].sort();for(const d of D){b.update(d);let l="",w;const j=new p(I.get(d));for(;j.hasNext();){const O=j.next();let H=n.clone(),T="";const f=[];let e=!1;for(const s of O)if(this.canonicalIssuer.hasId(s)?T+=this.canonicalIssuer.getId(s):(H.hasId(s)||f.push(s),T+=H.getId(s)),l.length!==0&&T>l){e=!0;break}if(!e){for(const s of f){const c=this.hashNDegreeQuads(s,H);if(T+=H.getId(s),T+=`<${c.hash}>`,H=c.issuer,l.length!==0&&T>l){e=!0;break}}e||(l.length===0||T<l)&&(l=T,w=H)}}b.update(l),n=w}return{hash:b.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}createHashToRelated(t,n){const a=new Map,b=this.blankNodeInfo.get(t).quads;for(const I of b)this._addRelatedBlankNodeHash({quad:I,component:I.subject,position:"s",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:I,component:I.object,position:"o",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:I,component:I.graph,position:"g",id:t,issuer:n,hashToRelated:a});return a}_hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const a=this.hashFirstDegreeQuads(t),b=n.get(a);b?b.push(t):n.set(a,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const a=n.value,b=this.blankNodeInfo.get(a);b?b.quads.add(t):this.blankNodeInfo.set(a,{quads:new Set([t]),hash:null})}_addRelatedBlankNodeHash({quad:t,component:n,position:a,id:b,issuer:I,hashToRelated:D}){if(!(n.termType==="BlankNode"&&n.value!==b))return;const d=n.value,l=this.hashRelatedBlankNode(d,t,I,a),w=D.get(l);w?w.push(d):D.set(l,[d])}_componentWithCanonicalId({component:t}){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}};function k(i,t){return i.hash<t.hash?-1:i.hash>t.hash?1:0}return Ee}/*!
 * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.
 */var je,ft;function en(){if(ft)return je;ft=1;const v=fe(),r=Gt();return je=class extends r{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new v("sha1")}modifyFirstDegreeComponent(y,k,i){return k.termType!=="BlankNode"?k:i==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:k.value===y?"_:a":"_:z"}}getRelatedPredicate(y){return y.predicate.value}createHashToRelated(y,k){const i=new Map,t=this.blankNodeInfo.get(y).quads;for(const n of t){let a,b;if(n.subject.termType==="BlankNode"&&n.subject.value!==y)b=n.subject.value,a="p";else if(n.object.termType==="BlankNode"&&n.object.value!==y)b=n.object.value,a="r";else continue;const I=this.hashRelatedBlankNode(b,n,k,a),D=i.get(I);D?D.push(b):i.set(I,[b])}return i}},je}var ht;function tn(){return ht||(ht=1,function(v){const r=Vt(),p=Zt(),y=Gt(),k=en();let i;try{i=Kt}catch{}function t(n){return Array.isArray(n)?n:v.NQuads.legacyDatasetToQuads(n)}v.NQuads=et(),v.IdentifierIssuer=Ze(),v._rdfCanonizeNative=function(n){return n&&(i=n),i},v.canonize=async function(n,a){const b=t(n);if(a.useNative){if(!i)throw new Error("rdf-canonize-native not available");if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return new Promise((I,D)=>i.canonize(b,a,(d,l)=>d?D(d):I(l)))}if(a.algorithm==="URDNA2015")return new r(a).main(b);if(a.algorithm==="URGNA2012"){if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new p(a).main(b)}throw"algorithm"in a?new Error("Invalid RDF Dataset Canonicalization algorithm: "+a.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")},v._canonizeSync=function(n,a){const b=t(n);if(a.useNative){if(!i)throw new Error("rdf-canonize-native not available");if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return i.canonizeSync(b,a)}if(a.algorithm==="URDNA2015")return new y(a).main(b);if(a.algorithm==="URGNA2012"){if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new k(a).main(b)}throw"algorithm"in a?new Error("Invalid RDF Dataset Canonicalization algorithm: "+a.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")}}(ye)),ye}var _e,pt;function tt(){return pt||(pt=1,_e=tn()),_e}var Re,gt;function ee(){if(gt)return Re;gt=1;const v={};return Re=v,v.isArray=Array.isArray,v.isBoolean=r=>typeof r=="boolean"||Object.prototype.toString.call(r)==="[object Boolean]",v.isDouble=r=>v.isNumber(r)&&(String(r).indexOf(".")!==-1||Math.abs(r)>=1e21),v.isEmptyObject=r=>v.isObject(r)&&Object.keys(r).length===0,v.isNumber=r=>typeof r=="number"||Object.prototype.toString.call(r)==="[object Number]",v.isNumeric=r=>!isNaN(parseFloat(r))&&isFinite(r),v.isObject=r=>Object.prototype.toString.call(r)==="[object Object]",v.isString=r=>typeof r=="string"||Object.prototype.toString.call(r)==="[object String]",v.isUndefined=r=>typeof r>"u",Re}var Se,yt;function re(){if(yt)return Se;yt=1;const v=ee(),r={};return Se=r,r.isSubject=p=>v.isObject(p)&&!("@value"in p||"@set"in p||"@list"in p)?Object.keys(p).length>1||!("@id"in p):!1,r.isSubjectReference=p=>v.isObject(p)&&Object.keys(p).length===1&&"@id"in p,r.isValue=p=>v.isObject(p)&&"@value"in p,r.isList=p=>v.isObject(p)&&"@list"in p,r.isGraph=p=>v.isObject(p)&&"@graph"in p&&Object.keys(p).filter(y=>y!=="@id"&&y!=="@index").length===1,r.isSimpleGraph=p=>r.isGraph(p)&&!("@id"in p),r.isBlankNode=p=>{if(v.isObject(p)){if("@id"in p){const y=p["@id"];return!v.isString(y)||y.indexOf("_:")===0}return Object.keys(p).length===0||!("@value"in p||"@set"in p||"@list"in p)}return!1},Se}var De,mt;function ne(){return mt||(mt=1,De=class extends Error{constructor(r="An unspecified JSON-LD error occurred.",p="jsonld.Error",y={}){super(r),this.name=p,this.message=r,this.details=y}}),De}var Oe,vt;function te(){if(vt)return Oe;vt=1;const v=re(),r=ee(),p=tt().IdentifierIssuer,y=ne(),k=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/,i=/(?:<[^>]*?>|"[^"]*?"|[^,])+/g,t=/\s*<([^>]*?)>\s*(?:;\s*(.*))?/,n=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g,a=/^@[a-zA-Z]+$/,b={headers:{accept:"application/ld+json, application/json"}},I={};Oe=I,I.IdentifierIssuer=p,I.REGEX_BCP47=k,I.REGEX_KEYWORD=a,I.clone=function(d){if(d&&typeof d=="object"){let l;if(r.isArray(d)){l=[];for(let w=0;w<d.length;++w)l[w]=I.clone(d[w])}else if(d instanceof Map){l=new Map;for(const[w,j]of d)l.set(w,I.clone(j))}else if(d instanceof Set){l=new Set;for(const w of d)l.add(I.clone(w))}else if(r.isObject(d)){l={};for(const w in d)l[w]=I.clone(d[w])}else l=d.toString();return l}return d},I.asArray=function(d){return Array.isArray(d)?d:[d]},I.buildHeaders=(d={})=>{if(Object.keys(d).some(w=>w.toLowerCase()==="accept"))throw new RangeError('Accept header may not be specified; only "'+b.headers.accept+'" is supported.');return Object.assign({Accept:b.headers.accept},d)},I.parseLinkHeader=d=>{const l={},w=d.match(i);for(let j=0;j<w.length;++j){let O=w[j].match(t);if(!O)continue;const H={target:O[1]},T=O[2];for(;O=n.exec(T);)H[O[1]]=O[2]===void 0?O[3]:O[2];const f=H.rel||"";Array.isArray(l[f])?l[f].push(H):l.hasOwnProperty(f)?l[f]=[l[f],H]:l[f]=H}return l},I.validateTypeValue=(d,l)=>{if(!r.isString(d)&&!(r.isArray(d)&&d.every(w=>r.isString(w)))){if(l&&r.isObject(d))switch(Object.keys(d).length){case 0:return;case 1:if("@default"in d&&I.asArray(d["@default"]).every(w=>r.isString(w)))return}throw new y('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{code:"invalid type value",value:d})}},I.hasProperty=(d,l)=>{if(d.hasOwnProperty(l)){const w=d[l];return!r.isArray(w)||w.length>0}return!1},I.hasValue=(d,l,w)=>{if(I.hasProperty(d,l)){let j=d[l];const O=v.isList(j);if(r.isArray(j)||O){O&&(j=j["@list"]);for(let H=0;H<j.length;++H)if(I.compareValues(w,j[H]))return!0}else if(!r.isArray(w))return I.compareValues(w,j)}return!1},I.addValue=(d,l,w,j)=>{if(j=j||{},"propertyIsArray"in j||(j.propertyIsArray=!1),"valueIsArray"in j||(j.valueIsArray=!1),"allowDuplicate"in j||(j.allowDuplicate=!0),"prependValue"in j||(j.prependValue=!1),j.valueIsArray)d[l]=w;else if(r.isArray(w)){w.length===0&&j.propertyIsArray&&!d.hasOwnProperty(l)&&(d[l]=[]),j.prependValue&&(w=w.concat(d[l]),d[l]=[]);for(let O=0;O<w.length;++O)I.addValue(d,l,w[O],j)}else if(d.hasOwnProperty(l)){const O=!j.allowDuplicate&&I.hasValue(d,l,w);!r.isArray(d[l])&&(!O||j.propertyIsArray)&&(d[l]=[d[l]]),O||(j.prependValue?d[l].unshift(w):d[l].push(w))}else d[l]=j.propertyIsArray?[w]:w},I.getValues=(d,l)=>[].concat(d[l]||[]),I.removeProperty=(d,l)=>{delete d[l]},I.removeValue=(d,l,w,j)=>{j=j||{},"propertyIsArray"in j||(j.propertyIsArray=!1);const O=I.getValues(d,l).filter(H=>!I.compareValues(H,w));O.length===0?I.removeProperty(d,l):O.length===1&&!j.propertyIsArray?d[l]=O[0]:d[l]=O},I.relabelBlankNodes=(d,l)=>{l=l||{};const w=l.issuer||new p("_:b");return D(w,d)},I.compareValues=(d,l)=>d===l||v.isValue(d)&&v.isValue(l)&&d["@value"]===l["@value"]&&d["@type"]===l["@type"]&&d["@language"]===l["@language"]&&d["@index"]===l["@index"]?!0:r.isObject(d)&&"@id"in d&&r.isObject(l)&&"@id"in l?d["@id"]===l["@id"]:!1,I.compareShortestLeast=(d,l)=>d.length<l.length?-1:l.length<d.length?1:d===l?0:d<l?-1:1;function D(d,l){if(r.isArray(l))for(let w=0;w<l.length;++w)l[w]=D(d,l[w]);else if(v.isList(l))l["@list"]=D(d,l["@list"]);else if(r.isObject(l)){v.isBlankNode(l)&&(l["@id"]=d.getId(l["@id"]));const w=Object.keys(l).sort();for(let j=0;j<w.length;++j){const O=w[j];O!=="@id"&&(l[O]=D(d,l[O]))}}return l}return Oe}var Le,bt;function nt(){if(bt)return Le;bt=1;const v="http://www.w3.org/1999/02/22-rdf-syntax-ns#",r="http://www.w3.org/2001/XMLSchema#";return Le={LINK_HEADER_REL:"http://www.w3.org/ns/json-ld#context",LINK_HEADER_CONTEXT:"http://www.w3.org/ns/json-ld#context",RDF:v,RDF_LIST:v+"List",RDF_FIRST:v+"first",RDF_REST:v+"rest",RDF_NIL:v+"nil",RDF_TYPE:v+"type",RDF_PLAIN_LITERAL:v+"PlainLiteral",RDF_XML_LITERAL:v+"XMLLiteral",RDF_JSON_LITERAL:v+"JSON",RDF_OBJECT:v+"object",RDF_LANGSTRING:v+"langString",XSD:r,XSD_BOOLEAN:r+"boolean",XSD_DOUBLE:r+"double",XSD_INTEGER:r+"integer",XSD_STRING:r+"string"},Le}var Ae,wt;function zt(){return wt||(wt=1,Ae=class{constructor(){this._requests={}}wrapLoader(r){const p=this;return p._loader=r,function(){return p.add.apply(p,arguments)}}async add(r){let p=this._requests[r];if(p)return Promise.resolve(p);p=this._requests[r]=this._loader(r);try{return await p}finally{delete this._requests[r]}}}),Ae}var Te,xt;function ie(){if(xt)return Te;xt=1;const v=ee(),r={};Te=r,r.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","authority","auth","user","password","hostname","port","path","directory","file","query","fragment"],regex:/^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}},r.parse=(y,k)=>{const i={},t=r.parsers[k||"full"],n=t.regex.exec(y);let a=t.keys.length;for(;a--;)i[t.keys[a]]=n[a]===void 0?null:n[a];return(i.scheme==="https"&&i.port==="443"||i.scheme==="http"&&i.port==="80")&&(i.href=i.href.replace(":"+i.port,""),i.authority=i.authority.replace(":"+i.port,""),i.port=null),i.normalizedPath=r.removeDotSegments(i.path),i},r.prependBase=(y,k)=>{if(y===null||r.isAbsolute(k))return k;(!y||v.isString(y))&&(y=r.parse(y||""));const i=r.parse(k),t={protocol:y.protocol||""};if(i.authority!==null)t.authority=i.authority,t.path=i.path,t.query=i.query;else if(t.authority=y.authority,i.path==="")t.path=y.path,i.query!==null?t.query=i.query:t.query=y.query;else{if(i.path.indexOf("/")===0)t.path=i.path;else{let a=y.path;a=a.substr(0,a.lastIndexOf("/")+1),(a.length>0||y.authority)&&a.substr(-1)!=="/"&&(a+="/"),a+=i.path,t.path=a}t.query=i.query}i.path!==""&&(t.path=r.removeDotSegments(t.path));let n=t.protocol;return t.authority!==null&&(n+="//"+t.authority),n+=t.path,t.query!==null&&(n+="?"+t.query),i.fragment!==null&&(n+="#"+i.fragment),n===""&&(n="./"),n},r.removeBase=(y,k)=>{if(y===null)return k;(!y||v.isString(y))&&(y=r.parse(y||""));let i="";if(y.href!==""?i+=(y.protocol||"")+"//"+(y.authority||""):k.indexOf("//")&&(i+="//"),k.indexOf(i)!==0)return k;const t=r.parse(k.substr(i.length)),n=y.normalizedPath.split("/"),a=t.normalizedPath.split("/"),b=t.fragment||t.query?0:1;for(;n.length>0&&a.length>b&&n[0]===a[0];)n.shift(),a.shift();let I="";if(n.length>0){n.pop();for(let D=0;D<n.length;++D)I+="../"}return I+=a.join("/"),t.query!==null&&(I+="?"+t.query),t.fragment!==null&&(I+="#"+t.fragment),I===""&&(I="./"),I},r.removeDotSegments=y=>{if(y.length===0)return"";const k=y.split("/"),i=[];for(;k.length>0;){const t=k.shift(),n=k.length===0;if(t==="."){n&&i.push("");continue}if(t===".."){i.pop(),n&&i.push("");continue}i.push(t)}return y[0]==="/"&&i.length>0&&i[0]!==""&&i.unshift(""),i.length===1&&i[0]===""?"/":i.join("/")};const p=/^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;return r.isAbsolute=y=>v.isString(y)&&p.test(y),r.isRelative=y=>v.isString(y),Te}var ke,It;function nn(){if(It)return ke;It=1;const{parseLinkHeader:v,buildHeaders:r}=te(),{LINK_HEADER_CONTEXT:p}=nt(),y=ne(),k=zt(),{prependBase:i}=ie(),t=/(^|(\r\n))link:/i;ke=({secure:a,headers:b={},xhr:I}={headers:{}})=>{return b=r(b),new k().wrapLoader(d);async function d(l){if(l.indexOf("http:")!==0&&l.indexOf("https:")!==0)throw new y('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url:l});if(a&&l.indexOf("https")!==0)throw new y(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,"jsonld.InvalidUrl",{code:"loading document failed",url:l});let w;try{w=await n(I,l,b)}catch(f){throw new y("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:l,cause:f})}if(w.status>=400)throw new y("URL could not be dereferenced: "+w.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url:l,httpStatusCode:w.status});let j={contextUrl:null,documentUrl:l,document:w.response},O=null;const H=w.getResponseHeader("Content-Type");let T;if(t.test(w.getAllResponseHeaders())&&(T=w.getResponseHeader("Link")),T&&H!=="application/ld+json"){const f=v(T),e=f[p];if(Array.isArray(e))throw new y("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"multiple context link headers",url:l});e&&(j.contextUrl=e.target),O=f.alternate,O&&O.type=="application/ld+json"&&!(H||"").match(/^application\/(\w*\+)?json$/)&&(j=await d(i(l,O.target)))}return j}};function n(a,b,I){a=a||XMLHttpRequest;const D=new a;return new Promise((d,l)=>{D.onload=()=>d(D),D.onerror=w=>l(w),D.open("GET",b,!0);for(const w in I)D.setRequestHeader(w,I[w]);D.send()})}return ke}var Me,Nt;function rn(){if(Nt)return Me;Nt=1;const v=nn(),r={};return Me=r,r.setupDocumentLoaders=function(p){typeof XMLHttpRequest<"u"&&(p.documentLoaders.xhr=v,p.useDocumentLoader("xhr"))},r.setupGlobals=function(p){typeof globalThis.JsonLdProcessor>"u"&&Object.defineProperty(globalThis,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:p.JsonLdProcessor})},Me}var qe,Et;function sn(){return Et||(Et=1,qe=function(v){v.prototype[Symbol.iterator]=function*(){for(let r=this.head;r;r=r.next)yield r.value}}),qe}var Je,jt;function an(){if(jt)return Je;jt=1,Je=v,v.Node=k,v.create=v;function v(i){var t=this;if(t instanceof v||(t=new v),t.tail=null,t.head=null,t.length=0,i&&typeof i.forEach=="function")i.forEach(function(b){t.push(b)});else if(arguments.length>0)for(var n=0,a=arguments.length;n<a;n++)t.push(arguments[n]);return t}v.prototype.removeNode=function(i){if(i.list!==this)throw new Error("removing node which does not belong to this list");var t=i.next,n=i.prev;return t&&(t.prev=n),n&&(n.next=t),i===this.head&&(this.head=t),i===this.tail&&(this.tail=n),i.list.length--,i.next=null,i.prev=null,i.list=null,t},v.prototype.unshiftNode=function(i){if(i!==this.head){i.list&&i.list.removeNode(i);var t=this.head;i.list=this,i.next=t,t&&(t.prev=i),this.head=i,this.tail||(this.tail=i),this.length++}},v.prototype.pushNode=function(i){if(i!==this.tail){i.list&&i.list.removeNode(i);var t=this.tail;i.list=this,i.prev=t,t&&(t.next=i),this.tail=i,this.head||(this.head=i),this.length++}},v.prototype.push=function(){for(var i=0,t=arguments.length;i<t;i++)p(this,arguments[i]);return this.length},v.prototype.unshift=function(){for(var i=0,t=arguments.length;i<t;i++)y(this,arguments[i]);return this.length},v.prototype.pop=function(){if(this.tail){var i=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,i}},v.prototype.shift=function(){if(this.head){var i=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,i}},v.prototype.forEach=function(i,t){t=t||this;for(var n=this.head,a=0;n!==null;a++)i.call(t,n.value,a,this),n=n.next},v.prototype.forEachReverse=function(i,t){t=t||this;for(var n=this.tail,a=this.length-1;n!==null;a--)i.call(t,n.value,a,this),n=n.prev},v.prototype.get=function(i){for(var t=0,n=this.head;n!==null&&t<i;t++)n=n.next;if(t===i&&n!==null)return n.value},v.prototype.getReverse=function(i){for(var t=0,n=this.tail;n!==null&&t<i;t++)n=n.prev;if(t===i&&n!==null)return n.value},v.prototype.map=function(i,t){t=t||this;for(var n=new v,a=this.head;a!==null;)n.push(i.call(t,a.value,this)),a=a.next;return n},v.prototype.mapReverse=function(i,t){t=t||this;for(var n=new v,a=this.tail;a!==null;)n.push(i.call(t,a.value,this)),a=a.prev;return n},v.prototype.reduce=function(i,t){var n,a=this.head;if(arguments.length>1)n=t;else if(this.head)a=this.head.next,n=this.head.value;else throw new TypeError("Reduce of empty list with no initial value");for(var b=0;a!==null;b++)n=i(n,a.value,b),a=a.next;return n},v.prototype.reduceReverse=function(i,t){var n,a=this.tail;if(arguments.length>1)n=t;else if(this.tail)a=this.tail.prev,n=this.tail.value;else throw new TypeError("Reduce of empty list with no initial value");for(var b=this.length-1;a!==null;b--)n=i(n,a.value,b),a=a.prev;return n},v.prototype.toArray=function(){for(var i=new Array(this.length),t=0,n=this.head;n!==null;t++)i[t]=n.value,n=n.next;return i},v.prototype.toArrayReverse=function(){for(var i=new Array(this.length),t=0,n=this.tail;n!==null;t++)i[t]=n.value,n=n.prev;return i},v.prototype.slice=function(i,t){t=t||this.length,t<0&&(t+=this.length),i=i||0,i<0&&(i+=this.length);var n=new v;if(t<i||t<0)return n;i<0&&(i=0),t>this.length&&(t=this.length);for(var a=0,b=this.head;b!==null&&a<i;a++)b=b.next;for(;b!==null&&a<t;a++,b=b.next)n.push(b.value);return n},v.prototype.sliceReverse=function(i,t){t=t||this.length,t<0&&(t+=this.length),i=i||0,i<0&&(i+=this.length);var n=new v;if(t<i||t<0)return n;i<0&&(i=0),t>this.length&&(t=this.length);for(var a=this.length,b=this.tail;b!==null&&a>t;a--)b=b.prev;for(;b!==null&&a>i;a--,b=b.prev)n.push(b.value);return n},v.prototype.splice=function(i,t,...n){i>this.length&&(i=this.length-1),i<0&&(i=this.length+i);for(var a=0,b=this.head;b!==null&&a<i;a++)b=b.next;for(var I=[],a=0;b&&a<t;a++)I.push(b.value),b=this.removeNode(b);b===null&&(b=this.tail),b!==this.head&&b!==this.tail&&(b=b.prev);for(var a=0;a<n.length;a++)b=r(this,b,n[a]);return I},v.prototype.reverse=function(){for(var i=this.head,t=this.tail,n=i;n!==null;n=n.prev){var a=n.prev;n.prev=n.next,n.next=a}return this.head=t,this.tail=i,this};function r(i,t,n){var a=t===i.head?new k(n,null,t,i):new k(n,t,t.next,i);return a.next===null&&(i.tail=a),a.prev===null&&(i.head=a),i.length++,a}function p(i,t){i.tail=new k(t,i.tail,null,i),i.head||(i.head=i.tail),i.length++}function y(i,t){i.head=new k(t,null,i.head,i),i.tail||(i.tail=i.head),i.length++}function k(i,t,n,a){if(!(this instanceof k))return new k(i,t,n,a);this.list=a,this.value=i,t?(t.next=this,this.prev=t):this.prev=null,n?(n.prev=this,this.next=n):this.next=null}try{sn()(v)}catch{}return Je}var Fe,_t;function $t(){if(_t)return Fe;_t=1;const v=an(),r=Symbol("max"),p=Symbol("length"),y=Symbol("lengthCalculator"),k=Symbol("allowStale"),i=Symbol("maxAge"),t=Symbol("dispose"),n=Symbol("noDisposeOnSet"),a=Symbol("lruList"),b=Symbol("cache"),I=Symbol("updateAgeOnGet"),D=()=>1;class d{constructor(e){if(typeof e=="number"&&(e={max:e}),e||(e={}),e.max&&(typeof e.max!="number"||e.max<0))throw new TypeError("max must be a non-negative number");this[r]=e.max||1/0;const s=e.length||D;if(this[y]=typeof s!="function"?D:s,this[k]=e.stale||!1,e.maxAge&&typeof e.maxAge!="number")throw new TypeError("maxAge must be a number");this[i]=e.maxAge||0,this[t]=e.dispose,this[n]=e.noDisposeOnSet||!1,this[I]=e.updateAgeOnGet||!1,this.reset()}set max(e){if(typeof e!="number"||e<0)throw new TypeError("max must be a non-negative number");this[r]=e||1/0,j(this)}get max(){return this[r]}set allowStale(e){this[k]=!!e}get allowStale(){return this[k]}set maxAge(e){if(typeof e!="number")throw new TypeError("maxAge must be a non-negative number");this[i]=e,j(this)}get maxAge(){return this[i]}set lengthCalculator(e){typeof e!="function"&&(e=D),e!==this[y]&&(this[y]=e,this[p]=0,this[a].forEach(s=>{s.length=this[y](s.value,s.key),this[p]+=s.length})),j(this)}get lengthCalculator(){return this[y]}get length(){return this[p]}get itemCount(){return this[a].length}rforEach(e,s){s=s||this;for(let c=this[a].tail;c!==null;){const _=c.prev;T(this,e,c,s),c=_}}forEach(e,s){s=s||this;for(let c=this[a].head;c!==null;){const _=c.next;T(this,e,c,s),c=_}}keys(){return this[a].toArray().map(e=>e.key)}values(){return this[a].toArray().map(e=>e.value)}reset(){this[t]&&this[a]&&this[a].length&&this[a].forEach(e=>this[t](e.key,e.value)),this[b]=new Map,this[a]=new v,this[p]=0}dump(){return this[a].map(e=>w(this,e)?!1:{k:e.key,v:e.value,e:e.now+(e.maxAge||0)}).toArray().filter(e=>e)}dumpLru(){return this[a]}set(e,s,c){if(c=c||this[i],c&&typeof c!="number")throw new TypeError("maxAge must be a number");const _=c?Date.now():0,u=this[y](s,e);if(this[b].has(e)){if(u>this[r])return O(this,this[b].get(e)),!1;const J=this[b].get(e).value;return this[t]&&(this[n]||this[t](e,J.value)),J.now=_,J.maxAge=c,J.value=s,this[p]+=u-J.length,J.length=u,this.get(e),j(this),!0}const N=new H(e,s,u,_,c);return N.length>this[r]?(this[t]&&this[t](e,s),!1):(this[p]+=N.length,this[a].unshift(N),this[b].set(e,this[a].head),j(this),!0)}has(e){if(!this[b].has(e))return!1;const s=this[b].get(e).value;return!w(this,s)}get(e){return l(this,e,!0)}peek(e){return l(this,e,!1)}pop(){const e=this[a].tail;return e?(O(this,e),e.value):null}del(e){O(this,this[b].get(e))}load(e){this.reset();const s=Date.now();for(let c=e.length-1;c>=0;c--){const _=e[c],u=_.e||0;if(u===0)this.set(_.k,_.v);else{const N=u-s;N>0&&this.set(_.k,_.v,N)}}}prune(){this[b].forEach((e,s)=>l(this,s,!1))}}const l=(f,e,s)=>{const c=f[b].get(e);if(c){const _=c.value;if(w(f,_)){if(O(f,c),!f[k])return}else s&&(f[I]&&(c.value.now=Date.now()),f[a].unshiftNode(c));return _.value}},w=(f,e)=>{if(!e||!e.maxAge&&!f[i])return!1;const s=Date.now()-e.now;return e.maxAge?s>e.maxAge:f[i]&&s>f[i]},j=f=>{if(f[p]>f[r])for(let e=f[a].tail;f[p]>f[r]&&e!==null;){const s=e.prev;O(f,e),e=s}},O=(f,e)=>{if(e){const s=e.value;f[t]&&f[t](s.key,s.value),f[p]-=s.length,f[b].delete(s.key),f[a].removeNode(e)}};class H{constructor(e,s,c,_,u){this.key=e,this.value=s,this.length=c,this.now=_,this.maxAge=u||0}}const T=(f,e,s,c)=>{let _=s.value;w(f,_)&&(O(f,s),f[k]||(_=void 0)),_&&e.call(c,_.value,_.key,f)};return Fe=d,Fe}var He,Rt;function on(){if(Rt)return He;Rt=1;const v=$t(),r=10;return He=class{constructor({document:y}){this.document=y,this.cache=new v({max:r})}getProcessed(y){return this.cache.get(y)}setProcessed(y,k){this.cache.set(y,k)}},He}var Ue,St;function ln(){if(St)return Ue;St=1;const{isArray:v,isObject:r,isString:p}=ee(),{asArray:y}=te(),{prependBase:k}=ie(),i=ne(),t=on(),n=10;Ue=class{constructor({sharedCache:D}){this.perOpCache=new Map,this.sharedCache=D}async resolve({activeCtx:D,context:d,documentLoader:l,base:w,cycles:j=new Set}){d&&r(d)&&d["@context"]&&(d=d["@context"]),d=y(d);const O=[];for(const H of d){if(p(H)){let e=this._get(H);e||(e=await this._resolveRemoteContext({activeCtx:D,url:H,documentLoader:l,base:w,cycles:j})),v(e)?O.push(...e):O.push(e);continue}if(H===null){O.push(new t({document:null}));continue}r(H)||a(d);const T=JSON.stringify(H);let f=this._get(T);f||(f=new t({document:H}),this._cacheResolvedContext({key:T,resolved:f,tag:"static"})),O.push(f)}return O}_get(D){let d=this.perOpCache.get(D);if(!d){const l=this.sharedCache.get(D);l&&(d=l.get("static"),d&&this.perOpCache.set(D,d))}return d}_cacheResolvedContext({key:D,resolved:d,tag:l}){if(this.perOpCache.set(D,d),l!==void 0){let w=this.sharedCache.get(D);w||(w=new Map,this.sharedCache.set(D,w)),w.set(l,d)}return d}async _resolveRemoteContext({activeCtx:D,url:d,documentLoader:l,base:w,cycles:j}){d=k(w,d);const{context:O,remoteDoc:H}=await this._fetchContext({activeCtx:D,url:d,documentLoader:l,cycles:j});w=H.documentUrl||d,b({context:O,base:w});const T=await this.resolve({activeCtx:D,context:O,documentLoader:l,base:w,cycles:j});return this._cacheResolvedContext({key:d,resolved:T,tag:H.tag}),T}async _fetchContext({activeCtx:D,url:d,documentLoader:l,cycles:w}){if(w.size>n)throw new i("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{code:D.processingMode==="json-ld-1.0"?"loading remote context failed":"context overflow",max:n});if(w.has(d))throw new i("Cyclical @context URLs detected.","jsonld.ContextUrlError",{code:D.processingMode==="json-ld-1.0"?"recursive context inclusion":"context overflow",url:d});w.add(d);let j,O;try{O=await l(d),j=O.document||null,p(j)&&(j=JSON.parse(j))}catch(H){throw new i("Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context.","jsonld.InvalidUrl",{code:"loading remote context failed",url:d,cause:H})}if(!r(j))throw new i("Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object.","jsonld.InvalidUrl",{code:"invalid remote context",url:d});return"@context"in j?j={"@context":j["@context"]}:j={"@context":{}},O.contextUrl&&(v(j["@context"])||(j["@context"]=[j["@context"]]),j["@context"].push(O.contextUrl)),{context:j,remoteDoc:O}}};function a(I){throw new i("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:I})}function b({context:I,base:D}){if(!I)return;const d=I["@context"];if(p(d)){I["@context"]=k(D,d);return}if(v(d)){for(let l=0;l<d.length;++l){const w=d[l];if(p(w)){d[l]=k(D,w);continue}r(w)&&b({context:{"@context":w},base:D})}return}if(r(d))for(const l in d)b({context:d[l],base:D})}return Ue}var Pe,Dt;function cn(){return Dt||(Dt=1,Pe=tt().NQuads),Pe}var Be,Ot;function oe(){if(Ot)return Be;Ot=1;const v=ne(),{isArray:r}=ee(),{asArray:p}=te(),y={};Be=y,y.defaultEventHandler=null,y.setupEventHandler=({options:t={}})=>{const n=[].concat(t.safe?y.safeEventHandler:[],t.eventHandler?p(t.eventHandler):[],y.defaultEventHandler?y.defaultEventHandler:[]);return n.length===0?null:n},y.handleEvent=({event:t,options:n})=>{k({event:t,handlers:n.eventHandler})};function k({event:t,handlers:n}){let a=!0;for(let b=0;a&&b<n.length;++b){a=!1;const I=n[b];if(r(I))a=k({event:t,handlers:I});else if(typeof I=="function")I({event:t,next:()=>{a=!0}});else if(typeof I=="object")t.code in I?I[t.code]({event:t,next:()=>{a=!0}}):a=!0;else throw new v("Invalid event handler.","jsonld.InvalidEventHandler",{event:t})}return a}const i=new Set(["empty object","free-floating scalar","invalid @language value","invalid property","null @id value","null @value value","object with only @id","object with only @language","object with only @list","object with only @value","relative @id reference","relative @type reference","relative @vocab reference","reserved @id value","reserved @reverse value","reserved term","blank node predicate","relative graph reference","relative object reference","relative predicate reference","relative subject reference","rdfDirection not set"]);return y.safeEventHandler=function({event:n,next:a}){if(n.level==="warning"&&i.has(n.code))throw new v("Safe mode validation error.","jsonld.ValidationError",{event:n});a()},y.logEventHandler=function({event:n,next:a}){console.log(`EVENT: ${n.message}`,{event:n}),a()},y.logWarningEventHandler=function({event:n,next:a}){n.level==="warning"&&console.warn(`WARNING: ${n.message}`,{event:n}),a()},y.unhandledEventHandler=function({event:n}){throw new v("No handler for event.","jsonld.UnhandledEvent",{event:n})},y.setDefaultEventHandler=function({eventHandler:t}={}){y.defaultEventHandler=t?p(t):null},Be}var Ve,Lt;function ae(){if(Lt)return Ve;Lt=1;const v=te(),r=ne(),{isArray:p,isObject:y,isString:k,isUndefined:i}=ee(),{isAbsolute:t,isRelative:n,prependBase:a}=ie(),{handleEvent:b}=oe(),{REGEX_BCP47:I,REGEX_KEYWORD:D,asArray:d,compareShortestLeast:l}=te(),w=new Map,j=1e4,O={};Ve=O,O.process=async({activeCtx:f,localCtx:e,options:s,propagate:c=!0,overrideProtected:_=!1,cycles:u=new Set})=>{if(y(e)&&"@context"in e&&p(e["@context"])&&(e=e["@context"]),d(e).length===0)return f;const m=[],J=[({event:F,next:o})=>{m.push(F),o()}];s.eventHandler&&J.push(s.eventHandler);const M=s;s={...s,eventHandler:J};const E=await s.contextResolver.resolve({activeCtx:f,context:e,documentLoader:s.documentLoader,base:s.base});y(E[0].document)&&typeof E[0].document["@propagate"]=="boolean"&&(c=E[0].document["@propagate"]);let h=f;!c&&!h.previousContext&&(h=h.clone(),h.previousContext=f);for(const F of E){let{document:o}=F;if(f=h,o===null){if(!_&&Object.keys(f.protected).length!==0)throw new r("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{code:"invalid context nullification"});h=f=O.getInitialContext(s).clone();continue}const A=F.getProcessed(f);if(A){if(M.eventHandler)for(const q of A.events)b({event:q,options:M});h=f=A.context;continue}if(y(o)&&"@context"in o&&(o=o["@context"]),!y(o))throw new r("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:o});h=h.clone();const L=new Map;if("@version"in o){if(o["@version"]!==1.1)throw new r("Unsupported JSON-LD version: "+o["@version"],"jsonld.UnsupportedVersion",{code:"invalid @version value",context:o});if(f.processingMode&&f.processingMode==="json-ld-1.0")throw new r("@version: "+o["@version"]+" not compatible with "+f.processingMode,"jsonld.ProcessingModeConflict",{code:"processing mode conflict",context:o});h.processingMode="json-ld-1.1",h["@version"]=o["@version"],L.set("@version",!0)}if(h.processingMode=h.processingMode||f.processingMode,"@base"in o){let q=o["@base"];if(!(q===null||t(q)))if(n(q))q=a(h["@base"],q);else throw new r('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:o});h["@base"]=q,L.set("@base",!0)}if("@vocab"in o){const q=o["@vocab"];if(q===null)delete h["@vocab"];else if(k(q)){if(!t(q)&&O.processingMode(h,1))throw new r('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:o});{const g=H(h,q,{vocab:!0,base:!0},void 0,void 0,s);t(g)||s.eventHandler&&b({event:{type:["JsonLdEvent"],code:"relative @vocab reference",level:"warning",message:"Relative @vocab reference found.",details:{vocab:g}},options:s}),h["@vocab"]=g}}else throw new r('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:o});L.set("@vocab",!0)}if("@language"in o){const q=o["@language"];if(q===null)delete h["@language"];else if(k(q))q.match(I)||s.eventHandler&&b({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:q}},options:s}),h["@language"]=q.toLowerCase();else throw new r('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:o});L.set("@language",!0)}if("@direction"in o){const q=o["@direction"];if(f.processingMode==="json-ld-1.0")throw new r("Invalid JSON-LD syntax; @direction not compatible with "+f.processingMode,"jsonld.SyntaxError",{code:"invalid context member",context:o});if(q===null)delete h["@direction"];else{if(q!=="ltr"&&q!=="rtl")throw new r('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:o});h["@direction"]=q}L.set("@direction",!0)}if("@propagate"in o){const q=o["@propagate"];if(f.processingMode==="json-ld-1.0")throw new r("Invalid JSON-LD syntax; @propagate not compatible with "+f.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:o});if(typeof q!="boolean")throw new r("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{code:"invalid @propagate value",context:e});L.set("@propagate",!0)}if("@import"in o){const q=o["@import"];if(f.processingMode==="json-ld-1.0")throw new r("Invalid JSON-LD syntax; @import not compatible with "+f.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:o});if(!k(q))throw new r("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{code:"invalid @import value",context:e});const g=await s.contextResolver.resolve({activeCtx:f,context:q,documentLoader:s.documentLoader,base:s.base});if(g.length!==1)throw new r("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{code:"invalid remote context",context:e});const V=g[0].getProcessed(f);if(V)o=V;else{const U=g[0].document;if("@import"in U)throw new r("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{code:"invalid context entry",context:e});for(const G in U)o.hasOwnProperty(G)||(o[G]=U[G]);g[0].setProcessed(f,o)}L.set("@import",!0)}L.set("@protected",o["@protected"]||!1);for(const q in o)if(O.createTermDefinition({activeCtx:h,localCtx:o,term:q,defined:L,options:s,overrideProtected:_}),y(o[q])&&"@context"in o[q]){const g=o[q]["@context"];let V=!0;if(k(g)){const U=a(s.base,g);u.has(U)?V=!1:u.add(U)}if(V)try{await O.process({activeCtx:h.clone(),localCtx:o[q]["@context"],overrideProtected:!0,options:s,cycles:u})}catch{throw new r("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{code:"invalid scoped context",context:o[q]["@context"],term:q})}}F.setProcessed(f,{context:h,events:m})}return h},O.createTermDefinition=({activeCtx:f,localCtx:e,term:s,defined:c,options:_,overrideProtected:u=!1})=>{if(c.has(s)){if(c.get(s))return;throw new r("Cyclical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:e,term:s})}c.set(s,!1);let N;if(e.hasOwnProperty(s)&&(N=e[s]),s==="@type"&&y(N)&&(N["@container"]||"@set")==="@set"&&O.processingMode(f,1.1)){const o=["@container","@id","@protected"],A=Object.keys(N);if(A.length===0||A.some(L=>!o.includes(L)))throw new r("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:e,term:s})}else{if(O.isKeyword(s))throw new r("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:e,term:s});if(s.match(D)){_.eventHandler&&b({event:{type:["JsonLdEvent"],code:"reserved term",level:"warning",message:'Terms beginning with "@" are reserved for future use and dropped.',details:{term:s}},options:_});return}else if(s==="")throw new r("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:e})}const m=f.mappings.get(s);f.mappings.has(s)&&f.mappings.delete(s);let J=!1;if((k(N)||N===null)&&(J=!0,N={"@id":N}),!y(N))throw new r("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:e});const M={};f.mappings.set(s,M),M.reverse=!1;const E=["@container","@id","@language","@reverse","@type"];O.processingMode(f,1.1)&&E.push("@context","@direction","@index","@nest","@prefix","@protected");for(const o in N)if(!E.includes(o))throw new r("Invalid JSON-LD syntax; a term definition must not contain "+o,"jsonld.SyntaxError",{code:"invalid term definition",context:e});const h=s.indexOf(":");if(M._termHasColon=h>0,"@reverse"in N){if("@id"in N)throw new r("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});if("@nest"in N)throw new r("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});const o=N["@reverse"];if(!k(o))throw new r("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(o.match(D)){_.eventHandler&&b({event:{type:["JsonLdEvent"],code:"reserved @reverse value",level:"warning",message:'@reverse values beginning with "@" are reserved for future use and dropped.',details:{reverse:o}},options:_}),m?f.mappings.set(s,m):f.mappings.delete(s);return}const A=H(f,o,{vocab:!0,base:!1},e,c,_);if(!t(A))throw new r("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});M["@id"]=A,M.reverse=!0}else if("@id"in N){let o=N["@id"];if(o&&!k(o))throw new r("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(o===null)M["@id"]=null;else if(!O.isKeyword(o)&&o.match(D)){_.eventHandler&&b({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:'@id values beginning with "@" are reserved for future use and dropped.',details:{id:o}},options:_}),m?f.mappings.set(s,m):f.mappings.delete(s);return}else if(o!==s){if(o=H(f,o,{vocab:!0,base:!1},e,c,_),!t(o)&&!O.isKeyword(o))throw new r("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(s.match(/(?::[^:])|\//)){const A=new Map(c).set(s,!0);if(H(f,s,{vocab:!0,base:!1},e,A,_)!==o)throw new r("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e})}M["@id"]=o,M._prefix=J&&!M._termHasColon&&o.match(/[:\/\?#\[\]@]$/)!==null}}if(!("@id"in M))if(M._termHasColon){const o=s.substr(0,h);if(e.hasOwnProperty(o)&&O.createTermDefinition({activeCtx:f,localCtx:e,term:o,defined:c,options:_}),f.mappings.has(o)){const A=s.substr(h+1);M["@id"]=f.mappings.get(o)["@id"]+A}else M["@id"]=s}else if(s==="@type")M["@id"]=s;else{if(!("@vocab"in f))throw new r("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e,term:s});M["@id"]=f["@vocab"]+s}if((N["@protected"]===!0||c.get("@protected")===!0&&N["@protected"]!==!1)&&(f.protected[s]=!0,M.protected=!0),c.set(s,!0),"@type"in N){let o=N["@type"];if(!k(o))throw new r("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:e});if(o==="@json"||o==="@none"){if(O.processingMode(f,1))throw new r(`Invalid JSON-LD syntax; an @context @type value must not be "${o}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{code:"invalid type mapping",context:e})}else if(o!=="@id"&&o!=="@vocab"){if(o=H(f,o,{vocab:!0,base:!1},e,c,_),!t(o))throw new r("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:e});if(o.indexOf("_:")===0)throw new r("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:e})}M["@type"]=o}if("@container"in N){const o=k(N["@container"])?[N["@container"]]:N["@container"]||[],A=["@list","@set","@index","@language"];let L=!0;const q=o.includes("@set");if(O.processingMode(f,1.1)){if(A.push("@graph","@id","@type"),o.includes("@list")){if(o.length!==1)throw new r("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{code:"invalid container mapping",context:e})}else if(o.includes("@graph")){if(o.some(g=>g!=="@graph"&&g!=="@id"&&g!=="@index"&&g!=="@set"))throw new r("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{code:"invalid container mapping",context:e})}else L&=o.length<=(q?2:1);if(o.includes("@type")&&(M["@type"]=M["@type"]||"@id",!["@id","@vocab"].includes(M["@type"])))throw new r("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{code:"invalid type mapping",context:e})}else L&=!p(N["@container"]),L&=o.length<=1;if(L&=o.every(g=>A.includes(g)),L&=!(q&&o.includes("@list")),!L)throw new r("Invalid JSON-LD syntax; @context @container value must be one of the following: "+A.join(", "),"jsonld.SyntaxError",{code:"invalid container mapping",context:e});if(M.reverse&&!o.every(g=>["@index","@set"].includes(g)))throw new r("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});M["@container"]=o}if("@index"in N){if(!("@container"in N)||!M["@container"].includes("@index"))throw new r(`Invalid JSON-LD syntax; @index without @index in @container: "${N["@index"]}" on term "${s}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:e});if(!k(N["@index"])||N["@index"].indexOf("@")===0)throw new r(`Invalid JSON-LD syntax; @index must expand to an IRI: "${N["@index"]}" on term "${s}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:e});M["@index"]=N["@index"]}if("@context"in N&&(M["@context"]=N["@context"]),"@language"in N&&!("@type"in N)){let o=N["@language"];if(o!==null&&!k(o))throw new r("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:e});o!==null&&(o=o.toLowerCase()),M["@language"]=o}if("@prefix"in N){if(s.match(/:|\//))throw new r("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{code:"invalid term definition",context:e});if(O.isKeyword(M["@id"]))throw new r("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{code:"invalid term definition",context:e});if(typeof N["@prefix"]=="boolean")M._prefix=N["@prefix"]===!0;else throw new r("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{code:"invalid @prefix value",context:e})}if("@direction"in N){const o=N["@direction"];if(o!==null&&o!=="ltr"&&o!=="rtl")throw new r('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:e});M["@direction"]=o}if("@nest"in N){const o=N["@nest"];if(!k(o)||o!=="@nest"&&o.indexOf("@")===0)throw new r("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{code:"invalid @nest value",context:e});M["@nest"]=o}// disallow aliasing @context and @preserve
const F=M["@id"];if(F==="@context"||F==="@preserve")throw new r("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:e});if(m&&m.protected&&!u&&(f.protected[s]=!0,M.protected=!0,!T(m,M)))throw new r("Invalid JSON-LD syntax; tried to redefine a protected term.","jsonld.SyntaxError",{code:"protected term redefinition",context:e,term:s})},O.expandIri=(f,e,s,c)=>H(f,e,s,void 0,void 0,c);function H(f,e,s,c,_,u){if(e===null||!k(e)||O.isKeyword(e))return e;if(e.match(D))return null;if(c&&c.hasOwnProperty(e)&&_.get(e)!==!0&&O.createTermDefinition({activeCtx:f,localCtx:c,term:e,defined:_,options:u}),s=s||{},s.vocab){const m=f.mappings.get(e);if(m===null)return null;if(y(m)&&"@id"in m)return m["@id"]}const N=e.indexOf(":");if(N>0){const m=e.substr(0,N),J=e.substr(N+1);if(m==="_"||J.indexOf("//")===0)return e;c&&c.hasOwnProperty(m)&&O.createTermDefinition({activeCtx:f,localCtx:c,term:m,defined:_,options:u});const M=f.mappings.get(m);if(M&&M._prefix)return M["@id"]+J;if(t(e))return e}if(s.vocab&&"@vocab"in f)e=f["@vocab"]+e;else if(s.base){let m,J;"@base"in f?f["@base"]?(J=a(u.base,f["@base"]),m=a(J,e)):(J=f["@base"],m=e):(J=u.base,m=a(u.base,e)),e=m}return e}O.getInitialContext=f=>{const e=JSON.stringify({processingMode:f.processingMode}),s=w.get(e);if(s)return s;const c={processingMode:f.processingMode,mappings:new Map,inverse:null,getInverse:_,clone:m,revertToPreviousContext:J,protected:{}};return w.size===j&&w.clear(),w.set(e,c),c;function _(){const M=this;if(M.inverse)return M.inverse;const E=M.inverse={},h=M.fastCurieMap={},F={},o=(M["@language"]||"@none").toLowerCase(),A=M["@direction"],L=M.mappings,q=[...L.keys()].sort(l);for(const g of q){const V=L.get(g);if(V===null)continue;let U=V["@container"]||"@none";if(U=[].concat(U).sort().join(""),V["@id"]===null)continue;const G=d(V["@id"]);for(const Q of G){let S=E[Q];const x=O.isKeyword(Q);if(S)!x&&!V._termHasColon&&F[Q].push(g);else if(E[Q]=S={},!x&&!V._termHasColon){F[Q]=[g];const R={iri:Q,terms:F[Q]};Q[0]in h?h[Q[0]].push(R):h[Q[0]]=[R]}if(S[U]||(S[U]={"@language":{},"@type":{},"@any":{}}),S=S[U],N(g,S["@any"],"@none"),V.reverse)N(g,S["@type"],"@reverse");else if(V["@type"]==="@none")N(g,S["@any"],"@none"),N(g,S["@language"],"@none"),N(g,S["@type"],"@none");else if("@type"in V)N(g,S["@type"],V["@type"]);else if("@language"in V&&"@direction"in V){const R=V["@language"],B=V["@direction"];R&&B?N(g,S["@language"],`${R}_${B}`.toLowerCase()):R?N(g,S["@language"],R.toLowerCase()):B?N(g,S["@language"],`_${B}`):N(g,S["@language"],"@null")}else"@language"in V?N(g,S["@language"],(V["@language"]||"@null").toLowerCase()):"@direction"in V?V["@direction"]?N(g,S["@language"],`_${V["@direction"]}`):N(g,S["@language"],"@none"):A?(N(g,S["@language"],`_${A}`),N(g,S["@language"],"@none"),N(g,S["@type"],"@none")):(N(g,S["@language"],o),N(g,S["@language"],"@none"),N(g,S["@type"],"@none"))}}for(const g in h)u(h,g,1);return E}function u(M,E,h){const F=M[E],o=M[E]={};let A,L;for(const q of F)A=q.iri,h>=A.length?L="":L=A[h],L in o?o[L].push(q):o[L]=[q];for(const q in o)q!==""&&u(o,q,h+1)}function N(M,E,h){E.hasOwnProperty(h)||(E[h]=M)}function m(){const M={};return M.mappings=v.clone(this.mappings),M.clone=this.clone,M.inverse=null,M.getInverse=this.getInverse,M.protected=v.clone(this.protected),this.previousContext&&(M.previousContext=this.previousContext.clone()),M.revertToPreviousContext=this.revertToPreviousContext,"@base"in this&&(M["@base"]=this["@base"]),"@language"in this&&(M["@language"]=this["@language"]),"@vocab"in this&&(M["@vocab"]=this["@vocab"]),M}function J(){return this.previousContext?this.previousContext.clone():this}},O.getContextValue=(f,e,s)=>{if(e===null)return s==="@context"?void 0:null;if(f.mappings.has(e)){const c=f.mappings.get(e);if(i(s))return c;if(c.hasOwnProperty(s))return c[s]}if(s==="@language"&&s in f||s==="@direction"&&s in f)return f[s];if(s!=="@context")return null},O.processingMode=(f,e)=>e.toString()>="1.1"?!f.processingMode||f.processingMode>="json-ld-"+e.toString():f.processingMode==="json-ld-1.0",O.isKeyword=f=>{if(!k(f)||f[0]!=="@")return!1;switch(f){case"@base":case"@container":case"@context":case"@default":case"@direction":case"@embed":case"@explicit":case"@graph":case"@id":case"@included":case"@index":case"@json":case"@language":case"@list":case"@nest":case"@none":case"@omitDefault":case"@prefix":case"@preserve":case"@protected":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@version":case"@vocab":return!0}return!1};function T(f,e){if(!(f&&typeof f=="object")||!(e&&typeof e=="object"))return f===e;const s=Array.isArray(f);if(s!==Array.isArray(e))return!1;if(s){if(f.length!==e.length)return!1;for(let u=0;u<f.length;++u)if(!T(f[u],e[u]))return!1;return!0}const c=Object.keys(f),_=Object.keys(e);if(c.length!==_.length)return!1;for(const u in f){let N=f[u],m=e[u];if(u==="@container"&&Array.isArray(N)&&Array.isArray(m)&&(N=N.slice().sort(),m=m.slice().sort()),!T(N,m))return!1}return!0}return Ve}var Ge,At;function un(){if(At)return Ge;At=1;const v=ne(),{isArray:r,isObject:p,isEmptyObject:y,isString:k,isUndefined:i}=ee(),{isList:t,isValue:n,isGraph:a,isSubject:b}=re(),{expandIri:I,getContextValue:D,isKeyword:d,process:l,processingMode:w}=ae(),{isAbsolute:j}=ie(),{REGEX_BCP47:O,REGEX_KEYWORD:H,addValue:T,asArray:f,getValues:e,validateTypeValue:s}=te(),{handleEvent:c}=oe(),_={};Ge=_,_.expand=async({activeCtx:E,activeProperty:h=null,element:F,options:o={},insideList:A=!1,insideIndex:L=!1,typeScopedContext:q=null})=>{if(F==null)return null;if(h==="@default"&&(o=Object.assign({},o,{isFrame:!1})),!r(F)&&!p(F))return!A&&(h===null||I(E,h,{vocab:!0},o)==="@graph")?(o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"free-floating scalar",level:"warning",message:"Dropping free-floating scalar not in a list.",details:{value:F}},options:o}),null):m({activeCtx:E,activeProperty:h,value:F,options:o});if(r(F)){let R=[];const B=D(E,h,"@container")||[];A=A||B.includes("@list");for(let $=0;$<F.length;++$){let P=await _.expand({activeCtx:E,activeProperty:h,element:F[$],options:o,insideIndex:L,typeScopedContext:q});A&&r(P)&&(P={"@list":P}),P!==null&&(r(P)?R=R.concat(P):R.push(P))}return R}const g=I(E,h,{vocab:!0},o),V=D(E,h,"@context");q=q||(E.previousContext?E:null);let U=Object.keys(F).sort(),G=!L;if(G&&q&&U.length<=2&&!U.includes("@context"))for(const R of U){const B=I(q,R,{vocab:!0},o);if(B==="@value"){G=!1,E=q;break}if(B==="@id"&&U.length===1){G=!1;break}}G&&(E=E.revertToPreviousContext()),i(V)||(E=await l({activeCtx:E,localCtx:V,propagate:!0,overrideProtected:!0,options:o})),"@context"in F&&(E=await l({activeCtx:E,localCtx:F["@context"],options:o})),q=E;let Q=null;for(const R of U)if(I(E,R,{vocab:!0},o)==="@type"){Q=Q||R;const $=F[R],P=Array.isArray($)?$.length>1?$.slice().sort():$:[$];for(const X of P){const W=D(q,X,"@context");i(W)||(E=await l({activeCtx:E,localCtx:W,options:o,propagate:!1}))}}let S={};await N({activeCtx:E,activeProperty:h,expandedActiveProperty:g,element:F,expandedParent:S,options:o,insideList:A,typeKey:Q,typeScopedContext:q}),U=Object.keys(S);let x=U.length;if("@value"in S){if("@type"in S&&("@language"in S||"@direction"in S))throw new v('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:S});let R=x-1;if("@type"in S&&(R-=1),"@index"in S&&(R-=1),"@language"in S&&(R-=1),"@direction"in S&&(R-=1),R!==0)throw new v('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:S});const B=S["@value"]===null?[]:f(S["@value"]),$=e(S,"@type");if(!(w(E,1.1)&&$.includes("@json")&&$.length===1))if(B.length===0)o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"null @value value",level:"warning",message:"Dropping null @value value.",details:{value:S}},options:o}),S=null;else{if(!B.every(P=>k(P)||y(P))&&"@language"in S)throw new v("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:S});if(!$.every(P=>j(P)&&!(k(P)&&P.indexOf("_:")===0)||y(P)))throw new v('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:S})}}else if("@type"in S&&!r(S["@type"]))S["@type"]=[S["@type"]];else if("@set"in S||"@list"in S){if(x>1&&!(x===2&&"@index"in S))throw new v('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",element:S});"@set"in S&&(S=S["@set"],U=Object.keys(S),x=U.length)}else x===1&&"@language"in S&&(o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"object with only @language",level:"warning",message:"Dropping object with only @language.",details:{value:S}},options:o}),S=null);return p(S)&&!o.keepFreeFloatingNodes&&!A&&(h===null||g==="@graph"||(D(E,h,"@container")||[]).includes("@graph"))&&(S=u({value:S,count:x,options:o})),S};function u({value:E,count:h,options:F}){if(h===0||"@value"in E||"@list"in E||h===1&&"@id"in E){if(F.eventHandler){let o,A;h===0?(o="empty object",A="Dropping empty object."):"@value"in E?(o="object with only @value",A="Dropping object with only @value."):"@list"in E?(o="object with only @list",A="Dropping object with only @list."):h===1&&"@id"in E&&(o="object with only @id",A="Dropping object with only @id."),c({event:{type:["JsonLdEvent"],code:o,level:"warning",message:A,details:{value:E}},options:F})}return null}return E}async function N({activeCtx:E,activeProperty:h,expandedActiveProperty:F,element:o,expandedParent:A,options:L={},insideList:q,typeKey:g,typeScopedContext:V}){const U=Object.keys(o).sort(),G=[];let Q;const S=o[g]&&I(E,r(o[g])?o[g][0]:o[g],{vocab:!0},{...L,typeExpansion:!0})==="@json";for(const x of U){let R=o[x],B;if(x==="@context")continue;const $=I(E,x,{vocab:!0},L);if($===null||!(j($)||d($))){L.eventHandler&&c({event:{type:["JsonLdEvent"],code:"invalid property",level:"warning",message:"Dropping property that did not expand into an absolute IRI or keyword.",details:{property:x,expandedProperty:$}},options:L});continue}if(d($)){if(F==="@reverse")throw new v("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{code:"invalid reverse property map",value:R});if($ in A&&$!=="@included"&&$!=="@type")throw new v("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{code:"colliding keywords",keyword:$})}if($==="@id"){if(!k(R)){if(!L.isFrame)throw new v('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value:R});if(p(R)){if(!y(R))throw new v('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:R})}else if(r(R)){if(!R.every(z=>k(z)))throw new v('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:R})}else throw new v('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:R})}T(A,"@id",f(R).map(z=>{if(k(z)){const K=I(E,z,{base:!0},L);return L.eventHandler&&(K===null?c(z===null?{event:{type:["JsonLdEvent"],code:"null @id value",level:"warning",message:"Null @id found.",details:{id:z}},options:L}:{event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:z}},options:L}):j(K)||c({event:{type:["JsonLdEvent"],code:"relative @id reference",level:"warning",message:"Relative @id reference found.",details:{id:z,expandedId:K}},options:L})),K}return z}),{propertyIsArray:L.isFrame});continue}if($==="@type"){p(R)&&(R=Object.fromEntries(Object.entries(R).map(([z,K])=>[I(V,z,{vocab:!0}),f(K).map(Y=>I(V,Y,{base:!0,vocab:!0},{...L,typeExpansion:!0}))]))),s(R,L.isFrame),T(A,"@type",f(R).map(z=>{if(k(z)){const K=I(V,z,{base:!0,vocab:!0},{...L,typeExpansion:!0});return K!=="@json"&&!j(K)&&L.eventHandler&&c({event:{type:["JsonLdEvent"],code:"relative @type reference",level:"warning",message:"Relative @type reference found.",details:{type:z}},options:L}),K}return z}),{propertyIsArray:!!L.isFrame});continue}if($==="@included"&&w(E,1.1)){const z=f(await _.expand({activeCtx:E,activeProperty:h,element:R,options:L}));if(!z.every(K=>b(K)))throw new v("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{code:"invalid @included value",value:R});T(A,"@included",z,{propertyIsArray:!0});continue}if($==="@graph"&&!(p(R)||r(R)))throw new v('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @graph value",value:R});if($==="@value"){Q=R,S&&w(E,1.1)?A["@value"]=R:T(A,"@value",R,{propertyIsArray:L.isFrame});continue}if($==="@language"){if(R===null)continue;if(!k(R)&&!L.isFrame)throw new v('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{code:"invalid language-tagged string",value:R});R=f(R).map(z=>k(z)?z.toLowerCase():z);for(const z of R)k(z)&&!z.match(O)&&L.eventHandler&&c({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:z}},options:L});T(A,"@language",R,{propertyIsArray:L.isFrame});continue}if($==="@direction"){if(!k(R)&&!L.isFrame)throw new v('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{code:"invalid base direction",value:R});R=f(R);for(const z of R)if(k(z)&&z!=="ltr"&&z!=="rtl")throw new v('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",value:R});T(A,"@direction",R,{propertyIsArray:L.isFrame});continue}if($==="@index"){if(!k(R))throw new v('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{code:"invalid @index value",value:R});T(A,"@index",R);continue}if($==="@reverse"){if(!p(R))throw new v('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value:R});if(B=await _.expand({activeCtx:E,activeProperty:"@reverse",element:R,options:L}),"@reverse"in B)for(const K in B["@reverse"])T(A,K,B["@reverse"][K],{propertyIsArray:!0});let z=A["@reverse"]||null;for(const K in B){if(K==="@reverse")continue;z===null&&(z=A["@reverse"]={}),T(z,K,[],{propertyIsArray:!0});const Y=B[K];for(let C=0;C<Y.length;++C){const Z=Y[C];if(n(Z)||t(Z))throw new v('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:B});T(z,K,Z,{propertyIsArray:!0})}}continue}if($==="@nest"){G.push(x);continue}let P=E;const X=D(E,x,"@context");i(X)||(P=await l({activeCtx:E,localCtx:X,propagate:!0,overrideProtected:!0,options:L}));const W=D(E,x,"@container")||[];if(W.includes("@language")&&p(R)){const z=D(P,x,"@direction");B=J(P,R,z,L)}else if(W.includes("@index")&&p(R)){const z=W.includes("@graph"),K=D(P,x,"@index")||"@index",Y=K!=="@index"&&I(E,K,{vocab:!0},L);B=await M({activeCtx:P,options:L,activeProperty:x,value:R,asGraph:z,indexKey:K,propertyIndex:Y})}else if(W.includes("@id")&&p(R)){const z=W.includes("@graph");B=await M({activeCtx:P,options:L,activeProperty:x,value:R,asGraph:z,indexKey:"@id"})}else if(W.includes("@type")&&p(R))B=await M({activeCtx:P.revertToPreviousContext(),options:L,activeProperty:x,value:R,asGraph:!1,indexKey:"@type"});else{const z=$==="@list";if(z||$==="@set"){let K=h;z&&F==="@graph"&&(K=null),B=await _.expand({activeCtx:P,activeProperty:K,element:R,options:L,insideList:z})}else D(E,x,"@type")==="@json"?B={"@type":"@json","@value":R}:B=await _.expand({activeCtx:P,activeProperty:x,element:R,options:L,insideList:!1})}if(!(B===null&&$!=="@value")){if($!=="@list"&&!t(B)&&W.includes("@list")&&(B={"@list":f(B)}),W.includes("@graph")&&!W.some(z=>z==="@id"||z==="@index")){if(B=f(B),L.isFrame||(B=B.filter(z=>{const K=Object.keys(z).length;return u({value:z,count:K,options:L})!==null})),B.length===0)continue;B=B.map(z=>({"@graph":f(z)}))}if(P.mappings.has(x)&&P.mappings.get(x).reverse){const z=A["@reverse"]=A["@reverse"]||{};B=f(B);for(let K=0;K<B.length;++K){const Y=B[K];if(n(Y)||t(Y))throw new v('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:B});T(z,$,Y,{propertyIsArray:!0})}continue}T(A,$,B,{propertyIsArray:!0})}}if("@value"in A&&!(A["@type"]==="@json"&&w(E,1.1))){if((p(Q)||r(Q))&&!L.isFrame)throw new v('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid value object value",value:Q})}for(const x of G){const R=r(o[x])?o[x]:[o[x]];for(const B of R){if(!p(B)||Object.keys(B).some($=>I(E,$,{vocab:!0},L)==="@value"))throw new v("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{code:"invalid @nest value",value:B});await N({activeCtx:E,activeProperty:h,expandedActiveProperty:F,element:B,expandedParent:A,options:L,insideList:q,typeScopedContext:V,typeKey:g})}}}function m({activeCtx:E,activeProperty:h,value:F,options:o}){if(F==null)return null;const A=I(E,h,{vocab:!0},o);if(A==="@id")return I(E,F,{base:!0},o);if(A==="@type")return I(E,F,{vocab:!0,base:!0},{...o,typeExpansion:!0});const L=D(E,h,"@type");if((L==="@id"||A==="@graph")&&k(F)){const g=I(E,F,{base:!0},o);return g===null&&F.match(H)&&o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:h}},options:o}),{"@id":g}}if(L==="@vocab"&&k(F))return{"@id":I(E,F,{vocab:!0,base:!0},o)};if(d(A))return F;const q={};if(L&&!["@id","@vocab","@none"].includes(L))q["@type"]=L;else if(k(F)){const g=D(E,h,"@language");g!==null&&(q["@language"]=g);const V=D(E,h,"@direction");V!==null&&(q["@direction"]=V)}return["boolean","number","string"].includes(typeof F)||(F=F.toString()),q["@value"]=F,q}function J(E,h,F,o){const A=[],L=Object.keys(h).sort();for(const q of L){const g=I(E,q,{vocab:!0},o);let V=h[q];r(V)||(V=[V]);for(const U of V){if(U===null)continue;if(!k(U))throw new v("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap:h});const G={"@value":U};g!=="@none"&&(q.match(O)||o.eventHandler&&c({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:q}},options:o}),G["@language"]=q.toLowerCase()),F&&(G["@direction"]=F),A.push(G)}}return A}async function M({activeCtx:E,options:h,activeProperty:F,value:o,asGraph:A,indexKey:L,propertyIndex:q}){const g=[],V=Object.keys(o).sort(),U=L==="@type";for(let G of V){if(U){const x=D(E,G,"@context");i(x)||(E=await l({activeCtx:E,localCtx:x,propagate:!1,options:h}))}let Q=o[G];r(Q)||(Q=[Q]),Q=await _.expand({activeCtx:E,activeProperty:F,element:Q,options:h,insideList:!1,insideIndex:!0});let S;q?G==="@none"?S="@none":S=m({activeCtx:E,activeProperty:L,value:G,options:h}):S=I(E,G,{vocab:!0},h),L==="@id"?G=I(E,G,{base:!0},h):U&&(G=S);for(let x of Q){if(A&&!a(x)&&(x={"@graph":[x]}),L==="@type")S==="@none"||(x["@type"]?x["@type"]=[G].concat(x["@type"]):x["@type"]=[G]);else{if(n(x)&&!["@language","@type","@index"].includes(L))throw new v(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${L}".`,"jsonld.SyntaxError",{code:"invalid value object",value:x});q?S!=="@none"&&T(x,q,S,{propertyIsArray:!0,prependValue:!0}):S!=="@none"&&!(L in x)&&(x[L]=G)}g.push(x)}}return g}return Ge}var ze,Tt;function he(){if(Tt)return ze;Tt=1;const{isKeyword:v}=ae(),r=re(),p=ee(),y=te(),k=ne(),i={};return ze=i,i.createMergedNodeMap=(t,n)=>{n=n||{};const a=n.issuer||new y.IdentifierIssuer("_:b"),b={"@default":{}};return i.createNodeMap(t,b,"@default",a),i.mergeNodeMaps(b)},i.createNodeMap=(t,n,a,b,I,D)=>{if(p.isArray(t)){for(const j of t)i.createNodeMap(j,n,a,b,void 0,D);return}if(!p.isObject(t)){D&&D.push(t);return}if(r.isValue(t)){if("@type"in t){let j=t["@type"];j.indexOf("_:")===0&&(t["@type"]=j=b.getId(j))}D&&D.push(t);return}else if(D&&r.isList(t)){const j=[];i.createNodeMap(t["@list"],n,a,b,I,j),D.push({"@list":j});return}if("@type"in t){const j=t["@type"];for(const O of j)O.indexOf("_:")===0&&b.getId(O)}p.isUndefined(I)&&(I=r.isBlankNode(t)?b.getId(t["@id"]):t["@id"]),D&&D.push({"@id":I});const d=n[a],l=d[I]=d[I]||{};l["@id"]=I;const w=Object.keys(t).sort();for(let j of w){if(j==="@id")continue;if(j==="@reverse"){const H={"@id":I},T=t["@reverse"];for(const f in T){const e=T[f];for(const s of e){let c=s["@id"];r.isBlankNode(s)&&(c=b.getId(c)),i.createNodeMap(s,n,a,b,c),y.addValue(d[c],f,H,{propertyIsArray:!0,allowDuplicate:!1})}}continue}if(j==="@graph"){I in n||(n[I]={}),i.createNodeMap(t[j],n,I,b);continue}if(j==="@included"){i.createNodeMap(t[j],n,a,b);continue}if(j!=="@type"&&v(j)){if(j==="@index"&&j in l&&(t[j]!==l[j]||t[j]["@id"]!==l[j]["@id"]))throw new k("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject:l});l[j]=t[j];continue}const O=t[j];if(j.indexOf("_:")===0&&(j=b.getId(j)),O.length===0){y.addValue(l,j,[],{propertyIsArray:!0});continue}for(let H of O)if(j==="@type"&&(H=H.indexOf("_:")===0?b.getId(H):H),r.isSubject(H)||r.isSubjectReference(H)){if("@id"in H&&!H["@id"])continue;const T=r.isBlankNode(H)?b.getId(H["@id"]):H["@id"];y.addValue(l,j,{"@id":T},{propertyIsArray:!0,allowDuplicate:!1}),i.createNodeMap(H,n,a,b,T)}else if(r.isValue(H))y.addValue(l,j,H,{propertyIsArray:!0,allowDuplicate:!1});else if(r.isList(H)){const T=[];i.createNodeMap(H["@list"],n,a,b,I,T),H={"@list":T},y.addValue(l,j,H,{propertyIsArray:!0,allowDuplicate:!1})}else i.createNodeMap(H,n,a,b,I),y.addValue(l,j,H,{propertyIsArray:!0,allowDuplicate:!1})}},i.mergeNodeMapGraphs=t=>{const n={};for(const a of Object.keys(t).sort())for(const b of Object.keys(t[a]).sort()){const I=t[a][b];b in n||(n[b]={"@id":b});const D=n[b];for(const d of Object.keys(I).sort())if(v(d)&&d!=="@type")D[d]=y.clone(I[d]);else for(const l of I[d])y.addValue(D,d,y.clone(l),{propertyIsArray:!0,allowDuplicate:!1})}return n},i.mergeNodeMaps=t=>{const n=t["@default"],a=Object.keys(t).sort();for(const b of a){if(b==="@default")continue;const I=t[b];let D=n[b];D?"@graph"in D||(D["@graph"]=[]):n[b]=D={"@id":b,"@graph":[]};const d=D["@graph"];for(const l of Object.keys(I).sort()){const w=I[l];r.isSubjectReference(w)||d.push(w)}}return n},ze}var $e,kt;function dn(){if(kt)return $e;kt=1;const{isSubjectReference:v}=re(),{createMergedNodeMap:r}=he(),p={};return $e=p,p.flatten=y=>{const k=r(y),i=[],t=Object.keys(k).sort();for(let n=0;n<t.length;++n){const a=k[t[n]];v(a)||i.push(a)}return i},$e}var Qe,Mt;function fn(){if(Mt)return Qe;Mt=1;const v=ne(),r=re(),p=ee(),{REGEX_BCP47:y,addValue:k}=te(),{handleEvent:i}=oe(),{RDF_LIST:t,RDF_FIRST:n,RDF_REST:a,RDF_NIL:b,RDF_TYPE:I,RDF_JSON_LITERAL:D,XSD_BOOLEAN:d,XSD_DOUBLE:l,XSD_INTEGER:w,XSD_STRING:j}=nt(),O={};Qe=O,O.fromRDF=async(T,f)=>{const{useRdfType:e=!1,useNativeTypes:s=!1,rdfDirection:c=null}=f,_={},u={"@default":_},N={};if(c){if(c==="compound-literal")throw new v("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:c});if(c!=="i18n-datatype")throw new v("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:c})}for(const M of T){const E=M.graph.termType==="DefaultGraph"?"@default":M.graph.value;E in u||(u[E]={}),E!=="@default"&&!(E in _)&&(_[E]={"@id":E});const h=u[E],F=M.subject.value,o=M.predicate.value,A=M.object;F in h||(h[F]={"@id":F});const L=h[F],q=A.termType.endsWith("Node");if(q&&!(A.value in h)&&(h[A.value]={"@id":A.value}),o===I&&!e&&q){k(L,"@type",A.value,{propertyIsArray:!0});continue}const g=H(A,s,c,f);if(k(L,o,g,{propertyIsArray:!0}),q)if(A.value===b){const V=h[A.value];"usages"in V||(V.usages=[]),V.usages.push({node:L,property:o,value:g})}else A.value in N?N[A.value]=!1:N[A.value]={node:L,property:o,value:g}}for(const M in u){const E=u[M];if(!(b in E))continue;const h=E[b];if(h.usages){for(let F of h.usages){let o=F.node,A=F.property,L=F.value;const q=[],g=[];let V=Object.keys(o).length;for(;A===a&&p.isObject(N[o["@id"]])&&p.isArray(o[n])&&o[n].length===1&&p.isArray(o[a])&&o[a].length===1&&(V===3||V===4&&p.isArray(o["@type"])&&o["@type"].length===1&&o["@type"][0]===t)&&(q.push(o[n][0]),g.push(o["@id"]),F=N[o["@id"]],o=F.node,A=F.property,L=F.value,V=Object.keys(o).length,!!r.isBlankNode(o)););delete L["@id"],L["@list"]=q.reverse();for(const U of g)delete E[U]}delete h.usages}}const m=[],J=Object.keys(_).sort();for(const M of J){const E=_[M];if(M in u){const h=E["@graph"]=[],F=u[M],o=Object.keys(F).sort();for(const A of o){const L=F[A];r.isSubjectReference(L)||h.push(L)}}r.isSubjectReference(E)||m.push(E)}return m};function H(T,f,e,s){if(T.termType.endsWith("Node"))return{"@id":T.value};const c={"@value":T.value};if(T.language)T.language.match(y)||s.eventHandler&&i({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:T.language}},options:s}),c["@language"]=T.language;else{let _=T.datatype.value;if(_||(_=j),_===D){_="@json";try{c["@value"]=JSON.parse(c["@value"])}catch(u){throw new v("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{code:"invalid JSON literal",value:c["@value"],cause:u})}}if(f){if(_===d)c["@value"]==="true"?c["@value"]=!0:c["@value"]==="false"&&(c["@value"]=!1);else if(p.isNumeric(c["@value"]))if(_===w){const u=parseInt(c["@value"],10);u.toFixed(0)===c["@value"]&&(c["@value"]=u)}else _===l&&(c["@value"]=parseFloat(c["@value"]));[d,w,l,j].includes(_)||(c["@type"]=_)}else if(e==="i18n-datatype"&&_.startsWith("https://www.w3.org/ns/i18n#")){const[,u,N]=_.split(/[#_]/);u.length>0&&(c["@language"]=u,u.match(y)||s.eventHandler&&i({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:u}},options:s})),c["@direction"]=N}else _!==j&&(c["@type"]=_)}return c}return Qe}var Xe,qt;function hn(){if(qt)return Xe;qt=1;const{createNodeMap:v}=he(),{isKeyword:r}=ae(),p=re(),y=Ct(),k=ne(),i=ee(),t=te(),{handleEvent:n}=oe(),{RDF_FIRST:a,RDF_REST:b,RDF_NIL:I,RDF_TYPE:D,RDF_JSON_LITERAL:d,RDF_LANGSTRING:l,XSD_BOOLEAN:w,XSD_DOUBLE:j,XSD_INTEGER:O,XSD_STRING:H}=nt(),{isAbsolute:T}=ie(),f={};Xe=f,f.toRDF=(_,u)=>{const N=new t.IdentifierIssuer("_:b"),m={"@default":{}};v(_,m,"@default",N);const J=[],M=Object.keys(m).sort();for(const E of M){let h;if(E==="@default")h={termType:"DefaultGraph",value:""};else if(T(E))E.startsWith("_:")?h={termType:"BlankNode"}:h={termType:"NamedNode"},h.value=E;else{u.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative graph reference",level:"warning",message:"Relative graph reference found.",details:{graph:E}},options:u});continue}e(J,m[E],h,N,u)}return J};function e(_,u,N,m,J){const M=Object.keys(u).sort();for(const E of M){const h=u[E],F=Object.keys(h).sort();for(let o of F){const A=h[o];if(o==="@type")o=D;else if(r(o))continue;for(const L of A){const q={termType:E.startsWith("_:")?"BlankNode":"NamedNode",value:E};if(!T(E)){J.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative subject reference",level:"warning",message:"Relative subject reference found.",details:{subject:E}},options:J});continue}const g={termType:o.startsWith("_:")?"BlankNode":"NamedNode",value:o};if(!T(o)){J.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative predicate reference",level:"warning",message:"Relative predicate reference found.",details:{predicate:o}},options:J});continue}if(g.termType==="BlankNode"&&!J.produceGeneralizedRdf){J.eventHandler&&n({event:{type:["JsonLdEvent"],code:"blank node predicate",level:"warning",message:"Dropping blank node predicate.",details:{property:m.getOldIds().find(U=>m.getId(U)===o)}},options:J});continue}const V=c(L,m,_,N,J.rdfDirection,J);V&&_.push({subject:q,predicate:g,object:V,graph:N})}}}}function s(_,u,N,m,J,M){const E={termType:"NamedNode",value:a},h={termType:"NamedNode",value:b},F={termType:"NamedNode",value:I},o=_.pop(),A=o?{termType:"BlankNode",value:u.getId()}:F;let L=A;for(const q of _){const g=c(q,u,N,m,J,M),V={termType:"BlankNode",value:u.getId()};N.push({subject:L,predicate:E,object:g,graph:m}),N.push({subject:L,predicate:h,object:V,graph:m}),L=V}if(o){const q=c(o,u,N,m,J,M);N.push({subject:L,predicate:E,object:q,graph:m}),N.push({subject:L,predicate:h,object:F,graph:m})}return A}function c(_,u,N,m,J,M){const E={};if(p.isValue(_)){E.termType="Literal",E.value=void 0,E.datatype={termType:"NamedNode"};let h=_["@value"];const F=_["@type"]||null;if(F==="@json")E.value=y(h),E.datatype.value=d;else if(i.isBoolean(h))E.value=h.toString(),E.datatype.value=F||w;else if(i.isDouble(h)||F===j)i.isDouble(h)||(h=parseFloat(h)),E.value=h.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),E.datatype.value=F||j;else if(i.isNumber(h))E.value=h.toFixed(0),E.datatype.value=F||O;else if("@direction"in _&&J==="i18n-datatype"){const o=(_["@language"]||"").toLowerCase(),A=_["@direction"],L=`https://www.w3.org/ns/i18n#${o}_${A}`;E.datatype.value=L,E.value=h}else{if("@direction"in _&&J==="compound-literal")throw new k("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:J});if("@direction"in _&&J)throw new k("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:J});"@language"in _?("@direction"in _&&!J&&M.eventHandler&&n({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:E.value}},options:M}),E.value=h,E.datatype.value=F||l,E.language=_["@language"]):("@direction"in _&&!J&&M.eventHandler&&n({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:E.value}},options:M}),E.value=h,E.datatype.value=F||H)}}else if(p.isList(_)){const h=s(_["@list"],u,N,m,J,M);E.termType=h.termType,E.value=h.value}else{const h=i.isObject(_)?_["@id"]:_;E.termType=h.startsWith("_:")?"BlankNode":"NamedNode",E.value=h}return E.termType==="NamedNode"&&!T(E.value)?(M.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative object reference",level:"warning",message:"Relative object reference found.",details:{object:E.value}},options:M}),null):E}return Xe}var Ke,Jt;function pn(){if(Jt)return Ke;Jt=1;const{isKeyword:v}=ae(),r=re(),p=ee(),y=te(),k=ie(),i=ne(),{createNodeMap:t,mergeNodeMapGraphs:n}=he(),a={};Ke=a,a.frameMergedOrDefault=(e,s,c)=>{const _={options:c,embedded:!1,graph:"@default",graphMap:{"@default":{}},subjectStack:[],link:{},bnodeMap:{}},u=new y.IdentifierIssuer("_:b");t(e,_.graphMap,"@default",u),c.merged&&(_.graphMap["@merged"]=n(_.graphMap),_.graph="@merged"),_.subjects=_.graphMap[_.graph];const N=[];a.frame(_,Object.keys(_.subjects).sort(),s,N),c.pruneBlankNodeIdentifiers&&(c.bnodesToClear=Object.keys(_.bnodeMap).filter(m=>_.bnodeMap[m].length===1));// remove @preserve from results
return c.link={},O(N,c)},a.frame=(e,s,c,_,u=null)=>{d(c),c=c[0];const N=e.options,m={embed:D(c,N,"embed"),explicit:D(c,N,"explicit"),requireAll:D(c,N,"requireAll")};e.link.hasOwnProperty(e.graph)||(e.link[e.graph]={});const J=e.link[e.graph],M=l(e,s,c,m),E=Object.keys(M).sort();for(const h of E){const F=M[h];if(u===null?e.uniqueEmbeds={[e.graph]:{}}:e.uniqueEmbeds[e.graph]=e.uniqueEmbeds[e.graph]||{},m.embed==="@link"&&h in J){H(_,u,J[h]);continue}const o={"@id":h};if(h.indexOf("_:")===0&&y.addValue(e.bnodeMap,h,o,{propertyIsArray:!0}),J[h]=o,(m.embed==="@first"||m.embed==="@last")&&e.is11)throw new i("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:c});if(!(!e.embedded&&e.uniqueEmbeds[e.graph].hasOwnProperty(h))){if(e.embedded&&(m.embed==="@never"||I(F,e.graph,e.subjectStack))){H(_,u,o);continue}if(e.embedded&&(m.embed=="@first"||m.embed=="@once")&&e.uniqueEmbeds[e.graph].hasOwnProperty(h)){H(_,u,o);continue}if(m.embed==="@last"&&h in e.uniqueEmbeds[e.graph]&&j(e,h),e.uniqueEmbeds[e.graph][h]={parent:_,property:u},e.subjectStack.push({subject:F,graph:e.graph}),h in e.graphMap){let A=!1,L=null;"@graph"in c?(L=c["@graph"][0],A=!(h==="@merged"||h==="@default"),p.isObject(L)||(L={})):(A=e.graph!=="@merged",L={}),A&&a.frame({...e,graph:h,embedded:!1},Object.keys(e.graphMap[h]).sort(),[L],o,"@graph")}"@included"in c&&a.frame({...e,embedded:!1},s,c["@included"],o,"@included");for(const A of Object.keys(F).sort()){if(v(A)){if(o[A]=y.clone(F[A]),A==="@type")for(const L of F["@type"])L.indexOf("_:")===0&&y.addValue(e.bnodeMap,L,o,{propertyIsArray:!0});continue}if(!(m.explicit&&!(A in c)))for(const L of F[A]){const q=A in c?c[A]:b(m);if(r.isList(L)){const g=c[A]&&c[A][0]&&c[A][0]["@list"]?c[A][0]["@list"]:b(m),V={"@list":[]};H(o,A,V);const U=L["@list"];for(const G of U)r.isSubjectReference(G)?a.frame({...e,embedded:!0},[G["@id"]],g,V,"@list"):H(V,"@list",y.clone(G))}else r.isSubjectReference(L)?a.frame({...e,embedded:!0},[L["@id"]],q,o,A):f(q[0],L)&&H(o,A,y.clone(L))}}for(const A of Object.keys(c).sort()){if(A==="@type"){if(!p.isObject(c[A][0])||!("@default"in c[A][0]))continue}else if(v(A))continue;const L=c[A][0]||{};if(!D(L,N,"omitDefault")&&!(A in o)){let g="@null";"@default"in L&&(g=y.clone(L["@default"])),p.isArray(g)||(g=[g]),o[A]=[{"@preserve":g}]}}for(const A of Object.keys(c["@reverse"]||{}).sort()){const L=c["@reverse"][A];for(const q of Object.keys(e.subjects))y.getValues(e.subjects[q],A).some(V=>V["@id"]===h)&&(o["@reverse"]=o["@reverse"]||{},y.addValue(o["@reverse"],A,[],{propertyIsArray:!0}),a.frame({...e,embedded:!0},[q],L,o["@reverse"][A],u))}H(_,u,o),e.subjectStack.pop()}}},a.cleanupNull=(e,s)=>{if(p.isArray(e))return e.map(_=>a.cleanupNull(_,s)).filter(_=>_);if(e==="@null")return null;if(p.isObject(e)){if("@id"in e){const c=e["@id"];if(s.link.hasOwnProperty(c)){const _=s.link[c].indexOf(e);if(_!==-1)return s.link[c][_];s.link[c].push(e)}else s.link[c]=[e]}for(const c in e)e[c]=a.cleanupNull(e[c],s)}return e};function b(e){const s={};for(const c in e)e[c]!==void 0&&(s["@"+c]=[e[c]]);return[s]}function I(e,s,c){for(let _=c.length-1;_>=0;--_){const u=c[_];if(u.graph===s&&u.subject["@id"]===e["@id"])return!0}return!1}function D(e,s,c){const _="@"+c;let u=_ in e?e[_][0]:s[c];if(c==="embed"){if(u===!0)u="@once";else if(u===!1)u="@never";else if(u!=="@always"&&u!=="@never"&&u!=="@link"&&u!=="@first"&&u!=="@last"&&u!=="@once")throw new i("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:e})}return u}function d(e){if(!p.isArray(e)||e.length!==1||!p.isObject(e[0]))throw new i("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{frame:e});if("@id"in e[0]){for(const s of y.asArray(e[0]["@id"]))if(!(p.isObject(s)||k.isAbsolute(s))||p.isString(s)&&s.indexOf("_:")===0)throw new i("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}if("@type"in e[0]){for(const s of y.asArray(e[0]["@type"]))if(!(p.isObject(s)||k.isAbsolute(s)||s==="@json")||p.isString(s)&&s.indexOf("_:")===0)throw new i("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}}function l(e,s,c,_){const u={};for(const N of s){const m=e.graphMap[e.graph][N];w(e,m,c,_)&&(u[N]=m)}return u}function w(e,s,c,_){let u=!0,N=!1;for(const m in c){let J=!1;const M=y.getValues(s,m),E=y.getValues(c,m).length===0;if(m==="@id"){if(p.isEmptyObject(c["@id"][0]||{})?J=!0:c["@id"].length>=0&&(J=c["@id"].includes(M[0])),!_.requireAll)return J}else if(m==="@type"){if(u=!1,E){if(M.length>0)return!1;J=!0}else if(c["@type"].length===1&&p.isEmptyObject(c["@type"][0]))J=M.length>0;else for(const h of c["@type"])p.isObject(h)&&"@default"in h?J=!0:J=J||M.some(F=>F===h);if(!_.requireAll)return J}else{if(v(m))continue;{const h=y.getValues(c,m)[0];let F=!1;if(h&&(d([h]),F="@default"in h),u=!1,M.length===0&&F)continue;if(M.length>0&&E)return!1;if(h===void 0){if(M.length>0)return!1;J=!0}else if(r.isList(h)){const o=h["@list"][0];if(r.isList(M[0])){const A=M[0]["@list"];r.isValue(o)?J=A.some(L=>f(o,L)):(r.isSubject(o)||r.isSubjectReference(o))&&(J=A.some(L=>T(e,o,L,_)))}}else r.isValue(h)?J=M.some(o=>f(h,o)):r.isSubjectReference(h)?J=M.some(o=>T(e,h,o,_)):p.isObject(h)?J=M.length>0:J=!1}}if(!J&&_.requireAll)return!1;N=N||J}return u||N}function j(e,s){const c=e.uniqueEmbeds[e.graph],_=c[s],u=_.parent,N=_.property,m={"@id":s};if(p.isArray(u)){for(let M=0;M<u.length;++M)if(y.compareValues(u[M],m)){u[M]=m;break}}else{const M=p.isArray(u[N]);y.removeValue(u,N,m,{propertyIsArray:M}),y.addValue(u,N,m,{propertyIsArray:M})}const J=M=>{const E=Object.keys(c);for(const h of E)h in c&&p.isObject(c[h].parent)&&c[h].parent["@id"]===M&&(delete c[h],J(h))};J(s)}/**
 * Removes the @preserve keywords from expanded result of framing.
 *
 * @param input the framed, framed output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */function O(e,s){if(p.isArray(e))return e.map(c=>O(c,s));if(p.isObject(e)){// remove @preserve
if("@preserve"in e)return e["@preserve"][0];if(r.isValue(e))return e;if(r.isList(e))return e["@list"]=O(e["@list"],s),e;if("@id"in e){const c=e["@id"];if(s.link.hasOwnProperty(c)){const _=s.link[c].indexOf(e);if(_!==-1)return s.link[c][_];s.link[c].push(e)}else s.link[c]=[e]}for(const c in e){if(c==="@id"&&s.bnodesToClear.includes(e[c])){delete e["@id"];continue}e[c]=O(e[c],s)}}return e}function H(e,s,c){p.isObject(e)?y.addValue(e,s,c,{propertyIsArray:!0}):e.push(c)}function T(e,s,c,_){if(!("@id"in c))return!1;const u=e.subjects[c["@id"]];return u&&w(e,u,s,_)}function f(e,s){const c=s["@value"],_=s["@type"],u=s["@language"],N=e["@value"]?p.isArray(e["@value"])?e["@value"]:[e["@value"]]:[],m=e["@type"]?p.isArray(e["@type"])?e["@type"]:[e["@type"]]:[],J=e["@language"]?p.isArray(e["@language"])?e["@language"]:[e["@language"]]:[];return N.length===0&&m.length===0&&J.length===0?!0:!(!(N.includes(c)||p.isEmptyObject(N[0]))||!(!_&&m.length===0||m.includes(_)||_&&p.isEmptyObject(m[0]))||!(!u&&J.length===0||J.includes(u)||u&&p.isEmptyObject(J[0])))}return Ke}var We,Ft;function gn(){if(Ft)return We;Ft=1;const v=ne(),{isArray:r,isObject:p,isString:y,isUndefined:k}=ee(),{isList:i,isValue:t,isGraph:n,isSimpleGraph:a,isSubjectReference:b}=re(),{expandIri:I,getContextValue:D,isKeyword:d,process:l,processingMode:w}=ae(),{removeBase:j,prependBase:O}=ie(),{REGEX_KEYWORD:H,addValue:T,asArray:f,compareShortestLeast:e}=te(),s={};We=s,s.compact=async({activeCtx:u,activeProperty:N=null,element:m,options:J={}})=>{if(r(m)){let E=[];for(let h=0;h<m.length;++h){const F=await s.compact({activeCtx:u,activeProperty:N,element:m[h],options:J});F!==null&&E.push(F)}return J.compactArrays&&E.length===1&&(D(u,N,"@container")||[]).length===0&&(E=E[0]),E}const M=D(u,N,"@context");if(k(M)||(u=await l({activeCtx:u,localCtx:M,propagate:!0,overrideProtected:!0,options:J})),p(m)){if(J.link&&"@id"in m&&J.link.hasOwnProperty(m["@id"])){const g=J.link[m["@id"]];for(let V=0;V<g.length;++V)if(g[V].expanded===m)return g[V].compacted}if(t(m)||b(m)){const g=s.compactValue({activeCtx:u,activeProperty:N,value:m,options:J});return J.link&&b(m)&&(J.link.hasOwnProperty(m["@id"])||(J.link[m["@id"]]=[]),J.link[m["@id"]].push({expanded:m,compacted:g})),g}if(i(m)&&(D(u,N,"@container")||[]).includes("@list"))return s.compact({activeCtx:u,activeProperty:N,element:m["@list"],options:J});const E=N==="@reverse",h={},F=u;!t(m)&&!b(m)&&(u=u.revertToPreviousContext());const o=D(F,N,"@context");k(o)||(u=await l({activeCtx:u,localCtx:o,propagate:!0,overrideProtected:!0,options:J})),J.link&&"@id"in m&&(J.link.hasOwnProperty(m["@id"])||(J.link[m["@id"]]=[]),J.link[m["@id"]].push({expanded:m,compacted:h}));let A=m["@type"]||[];A.length>1&&(A=Array.from(A).sort());const L=u;for(const g of A){const V=s.compactIri({activeCtx:L,iri:g,relativeTo:{vocab:!0}}),U=D(F,V,"@context");k(U)||(u=await l({activeCtx:u,localCtx:U,options:J,propagate:!1}))}const q=Object.keys(m).sort();for(const g of q){const V=m[g];if(g==="@id"){let U=f(V).map(Q=>s.compactIri({activeCtx:u,iri:Q,relativeTo:{vocab:!1},base:J.base}));U.length===1&&(U=U[0]);const G=s.compactIri({activeCtx:u,iri:"@id",relativeTo:{vocab:!0}});h[G]=U;continue}if(g==="@type"){let U=f(V).map(R=>s.compactIri({activeCtx:F,iri:R,relativeTo:{vocab:!0}}));U.length===1&&(U=U[0]);const G=s.compactIri({activeCtx:u,iri:"@type",relativeTo:{vocab:!0}}),x=(D(u,G,"@container")||[]).includes("@set")&&w(u,1.1)||r(U)&&V.length===0;T(h,G,U,{propertyIsArray:x});continue}if(g==="@reverse"){const U=await s.compact({activeCtx:u,activeProperty:"@reverse",element:V,options:J});for(const G in U)if(u.mappings.has(G)&&u.mappings.get(G).reverse){const Q=U[G],x=(D(u,G,"@container")||[]).includes("@set")||!J.compactArrays;T(h,G,Q,{propertyIsArray:x}),delete U[G]}if(Object.keys(U).length>0){const G=s.compactIri({activeCtx:u,iri:g,relativeTo:{vocab:!0}});T(h,G,U)}continue}if(g==="@preserve"){const U=await s.compact({activeCtx:u,activeProperty:N,element:V,options:J});r(U)&&U.length===0||T(h,g,U);continue}if(g==="@index"){if((D(u,N,"@container")||[]).includes("@index"))continue;const G=s.compactIri({activeCtx:u,iri:g,relativeTo:{vocab:!0}});T(h,G,V);continue}if(g!=="@graph"&&g!=="@list"&&g!=="@included"&&d(g)){const U=s.compactIri({activeCtx:u,iri:g,relativeTo:{vocab:!0}});T(h,U,V);continue}if(!r(V))throw new v("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");if(V.length===0){const U=s.compactIri({activeCtx:u,iri:g,value:V,relativeTo:{vocab:!0},reverse:E}),G=u.mappings.has(U)?u.mappings.get(U)["@nest"]:null;let Q=h;G&&(_(u,G,J),p(h[G])||(h[G]={}),Q=h[G]),T(Q,U,V,{propertyIsArray:!0})}for(const U of V){const G=s.compactIri({activeCtx:u,iri:g,value:U,relativeTo:{vocab:!0},reverse:E}),Q=u.mappings.has(G)?u.mappings.get(G)["@nest"]:null;let S=h;Q&&(_(u,Q,J),p(h[Q])||(h[Q]={}),S=h[Q]);const x=D(u,G,"@container")||[],R=n(U),B=i(U);let $;B?$=U["@list"]:R&&($=U["@graph"]);let P=await s.compact({activeCtx:u,activeProperty:G,element:B||R?$:U,options:J});if(B)if(r(P)||(P=[P]),!x.includes("@list"))P={[s.compactIri({activeCtx:u,iri:"@list",relativeTo:{vocab:!0}})]:P},"@index"in U&&(P[s.compactIri({activeCtx:u,iri:"@index",relativeTo:{vocab:!0}})]=U["@index"]);else{T(S,G,P,{valueIsArray:!0,allowDuplicate:!0});continue}if(R)if(x.includes("@graph")&&(x.includes("@id")||x.includes("@index")&&a(U))){let X;S.hasOwnProperty(G)?X=S[G]:S[G]=X={};const W=(x.includes("@id")?U["@id"]:U["@index"])||s.compactIri({activeCtx:u,iri:"@none",relativeTo:{vocab:!0}});T(X,W,P,{propertyIsArray:!J.compactArrays||x.includes("@set")})}else x.includes("@graph")&&a(U)?(r(P)&&P.length>1&&(P={"@included":P}),T(S,G,P,{propertyIsArray:!J.compactArrays||x.includes("@set")})):(r(P)&&P.length===1&&J.compactArrays&&(P=P[0]),P={[s.compactIri({activeCtx:u,iri:"@graph",relativeTo:{vocab:!0}})]:P},"@id"in U&&(P[s.compactIri({activeCtx:u,iri:"@id",relativeTo:{vocab:!0}})]=U["@id"]),"@index"in U&&(P[s.compactIri({activeCtx:u,iri:"@index",relativeTo:{vocab:!0}})]=U["@index"]),T(S,G,P,{propertyIsArray:!J.compactArrays||x.includes("@set")}));else if(x.includes("@language")||x.includes("@index")||x.includes("@id")||x.includes("@type")){let X;S.hasOwnProperty(G)?X=S[G]:S[G]=X={};let W;if(x.includes("@language"))t(P)&&(P=P["@value"]),W=U["@language"];else if(x.includes("@index")){const z=D(u,G,"@index")||"@index",K=s.compactIri({activeCtx:u,iri:z,relativeTo:{vocab:!0}});if(z==="@index")W=U["@index"],delete P[K];else{let Y;if([W,...Y]=f(P[z]||[]),!y(W))W=null;else switch(Y.length){case 0:delete P[z];break;case 1:P[z]=Y[0];break;default:P[z]=Y;break}}}else if(x.includes("@id")){const z=s.compactIri({activeCtx:u,iri:"@id",relativeTo:{vocab:!0}});W=P[z],delete P[z]}else if(x.includes("@type")){const z=s.compactIri({activeCtx:u,iri:"@type",relativeTo:{vocab:!0}});let K;switch([W,...K]=f(P[z]||[]),K.length){case 0:delete P[z];break;case 1:P[z]=K[0];break;default:P[z]=K;break}Object.keys(P).length===1&&"@id"in U&&(P=await s.compact({activeCtx:u,activeProperty:G,element:{"@id":U["@id"]},options:J}))}W||(W=s.compactIri({activeCtx:u,iri:"@none",relativeTo:{vocab:!0}})),T(X,W,P,{propertyIsArray:x.includes("@set")})}else{const X=!J.compactArrays||x.includes("@set")||x.includes("@list")||r(P)&&P.length===0||g==="@list"||g==="@graph";T(S,G,P,{propertyIsArray:X})}}}return h}return m},s.compactIri=({activeCtx:u,iri:N,value:m=null,relativeTo:J={vocab:!1},reverse:M=!1,base:E=null})=>{if(N===null)return N;u.isPropertyTermScoped&&u.previousContext&&(u=u.previousContext);const h=u.getInverse();if(d(N)&&N in h&&"@none"in h[N]&&"@type"in h[N]["@none"]&&"@none"in h[N]["@none"]["@type"])return h[N]["@none"]["@type"]["@none"];if(J.vocab&&N in h){const q=u["@language"]||"@none",g=[];p(m)&&"@index"in m&&!("@graph"in m)&&g.push("@index","@index@set"),p(m)&&"@preserve"in m&&(m=m["@preserve"][0]),n(m)?("@index"in m&&g.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in m&&g.push("@graph@id","@graph@id@set"),g.push("@graph","@graph@set","@set"),"@index"in m||g.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in m||g.push("@graph@id","@graph@id@set")):p(m)&&!t(m)&&g.push("@id","@id@set","@type","@set@type");let V="@language",U="@null";if(M)V="@type",U="@reverse",g.push("@set");else if(i(m)){"@index"in m||g.push("@list");const Q=m["@list"];if(Q.length===0)V="@any",U="@none";else{let S=Q.length===0?q:null,x=null;for(let R=0;R<Q.length;++R){const B=Q[R];let $="@none",P="@none";if(t(B))if("@direction"in B){const X=(B["@language"]||"").toLowerCase(),W=B["@direction"];$=`${X}_${W}`}else"@language"in B?$=B["@language"].toLowerCase():"@type"in B?P=B["@type"]:$="@null";else P="@id";if(S===null?S=$:$!==S&&t(B)&&(S="@none"),x===null?x=P:P!==x&&(x="@none"),S==="@none"&&x==="@none")break}S=S||"@none",x=x||"@none",x!=="@none"?(V="@type",U=x):U=S}}else{if(t(m))if("@language"in m&&!("@index"in m)){g.push("@language","@language@set"),U=m["@language"];const Q=m["@direction"];Q&&(U=`${U}_${Q}`)}else"@direction"in m&&!("@index"in m)?U=`_${m["@direction"]}`:"@type"in m&&(V="@type",U=m["@type"]);else V="@type",U="@id";g.push("@set")}g.push("@none"),p(m)&&!("@index"in m)&&g.push("@index","@index@set"),t(m)&&Object.keys(m).length===1&&g.push("@language","@language@set");const G=c(u,N,m,g,V,U);if(G!==null)return G}if(J.vocab&&"@vocab"in u){const q=u["@vocab"];if(N.indexOf(q)===0&&N!==q){const g=N.substr(q.length);if(!u.mappings.has(g))return g}}let F=null;const o=[];let A=u.fastCurieMap;const L=N.length-1;for(let q=0;q<L&&N[q]in A;++q)A=A[N[q]],""in A&&o.push(A[""][0]);for(let q=o.length-1;q>=0;--q){const g=o[q],V=g.terms;for(const U of V){const G=U+":"+N.substr(g.iri.length);u.mappings.get(U)._prefix&&(!u.mappings.has(G)||m===null&&u.mappings.get(G)["@id"]===N)&&(F===null||e(G,F)<0)&&(F=G)}}if(F!==null)return F;for(const[q,g]of u.mappings)if(g&&g._prefix&&N.startsWith(q+":"))throw new v(`Absolute IRI "${N}" confused with prefix "${q}".`,"jsonld.SyntaxError",{code:"IRI confused with prefix",context:u});if(!J.vocab)if("@base"in u)if(u["@base"]){const q=j(O(E,u["@base"]),N);return H.test(q)?`./${q}`:q}else return N;else return j(E,N);return N},s.compactValue=({activeCtx:u,activeProperty:N,value:m,options:J})=>{if(t(m)){const F=D(u,N,"@type"),o=D(u,N,"@language"),A=D(u,N,"@direction"),L=D(u,N,"@container")||[],q="@index"in m&&!L.includes("@index");if(!q&&F!=="@none"&&(m["@type"]===F||"@language"in m&&m["@language"]===o&&"@direction"in m&&m["@direction"]===A||"@language"in m&&m["@language"]===o||"@direction"in m&&m["@direction"]===A))return m["@value"];const g=Object.keys(m).length,V=g===1||g===2&&"@index"in m&&!q,U="@language"in u,G=y(m["@value"]),Q=u.mappings.has(N)&&u.mappings.get(N)["@language"]===null;if(V&&F!=="@none"&&(!U||!G||Q))return m["@value"];const S={};return q&&(S[s.compactIri({activeCtx:u,iri:"@index",relativeTo:{vocab:!0}})]=m["@index"]),"@type"in m?S[s.compactIri({activeCtx:u,iri:"@type",relativeTo:{vocab:!0}})]=s.compactIri({activeCtx:u,iri:m["@type"],relativeTo:{vocab:!0}}):"@language"in m&&(S[s.compactIri({activeCtx:u,iri:"@language",relativeTo:{vocab:!0}})]=m["@language"]),"@direction"in m&&(S[s.compactIri({activeCtx:u,iri:"@direction",relativeTo:{vocab:!0}})]=m["@direction"]),S[s.compactIri({activeCtx:u,iri:"@value",relativeTo:{vocab:!0}})]=m["@value"],S}const M=I(u,N,{vocab:!0},J),E=D(u,N,"@type"),h=s.compactIri({activeCtx:u,iri:m["@id"],relativeTo:{vocab:E==="@vocab"},base:J.base});return E==="@id"||E==="@vocab"||M==="@graph"?h:{[s.compactIri({activeCtx:u,iri:"@id",relativeTo:{vocab:!0}})]:h}};function c(u,N,m,J,M,E){E===null&&(E="@null");const h=[];if((E==="@id"||E==="@reverse")&&p(m)&&"@id"in m){E==="@reverse"&&h.push("@reverse");const o=s.compactIri({activeCtx:u,iri:m["@id"],relativeTo:{vocab:!0}});u.mappings.has(o)&&u.mappings.get(o)&&u.mappings.get(o)["@id"]===m["@id"]?h.push.apply(h,["@vocab","@id"]):h.push.apply(h,["@id","@vocab"])}else{h.push(E);const o=h.find(A=>A.includes("_"));o&&h.push(o.replace(/^[^_]+_/,"_"))}h.push("@none");const F=u.inverse[N];for(const o of J){if(!(o in F))continue;const A=F[o][M];for(const L of h)if(L in A)return A[L]}return null}function _(u,N,m){if(I(u,N,{vocab:!0},m)!=="@nest")throw new v("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{code:"invalid @nest value"})}return We}var Ce,Ht;function yn(){return Ht||(Ht=1,Ce=v=>{class r{toString(){return"[object JsonLdProcessor]"}}return Object.defineProperty(r,"prototype",{writable:!1,enumerable:!1}),Object.defineProperty(r.prototype,"constructor",{writable:!0,enumerable:!1,configurable:!0,value:r}),r.compact=function(p,y){return arguments.length<2?Promise.reject(new TypeError("Could not compact, too few arguments.")):v.compact(p,y)},r.expand=function(p){return arguments.length<1?Promise.reject(new TypeError("Could not expand, too few arguments.")):v.expand(p)},r.flatten=function(p){return arguments.length<1?Promise.reject(new TypeError("Could not flatten, too few arguments.")):v.flatten(p)},r}),Ce}/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2022 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */var Ye,Ut;function mn(){if(Ut)return Ye;Ut=1;const v=tt(),r=rn(),p=te(),y=ln(),k=p.IdentifierIssuer,i=ne(),t=$t(),n=cn(),{expand:a}=un(),{flatten:b}=dn(),{fromRDF:I}=fn(),{toRDF:D}=hn(),{frameMergedOrDefault:d,cleanupNull:l}=pn(),{isArray:w,isObject:j,isString:O}=ee(),{isSubjectReference:H}=re(),{expandIri:T,getInitialContext:f,process:e,processingMode:s}=ae(),{compact:c,compactIri:_}=gn(),{createNodeMap:u,createMergedNodeMap:N,mergeNodeMaps:m}=he(),{logEventHandler:J,logWarningEventHandler:M,safeEventHandler:E,setDefaultEventHandler:h,setupEventHandler:F,strictEventHandler:o,unhandledEventHandler:A}=oe(),L=function(g){const V={},G=new t({max:100});g.compact=async function(S,x,R){if(arguments.length<2)throw new TypeError("Could not compact, too few arguments.");if(x===null)throw new i("The compaction context must not be null.","jsonld.CompactError",{code:"invalid local context"});if(S===null)return null;R=Q(R,{base:O(S)?S:"",compactArrays:!0,compactToRelative:!0,graph:!1,skipExpansion:!1,link:!1,issuer:new k("_:b"),contextResolver:new y({sharedCache:G})}),R.link&&(R.skipExpansion=!0),R.compactToRelative||delete R.base;let B;R.skipExpansion?B=S:B=await g.expand(S,R);const $=await g.processContext(f(R),x,R);let P=await c({activeCtx:$,element:B,options:R});R.compactArrays&&!R.graph&&w(P)?P.length===1?P=P[0]:P.length===0&&(P={}):R.graph&&j(P)&&(P=[P]),j(x)&&"@context"in x&&(x=x["@context"]),x=p.clone(x),w(x)||(x=[x]);const X=x;x=[];for(let z=0;z<X.length;++z)(!j(X[z])||Object.keys(X[z]).length>0)&&x.push(X[z]);const W=x.length>0;if(x.length===1&&(x=x[0]),w(P)){const z=_({activeCtx:$,iri:"@graph",relativeTo:{vocab:!0}}),K=P;P={},W&&(P["@context"]=x),P[z]=K}else if(j(P)&&W){const z=P;P={"@context":x};for(const K in z)P[K]=z[K]}return P},g.expand=async function(S,x){if(arguments.length<1)throw new TypeError("Could not expand, too few arguments.");x=Q(x,{keepFreeFloatingNodes:!1,contextResolver:new y({sharedCache:G})});const R={},B=[];if("expandContext"in x){const W=p.clone(x.expandContext);j(W)&&"@context"in W?R.expandContext=W:R.expandContext={"@context":W},B.push(R.expandContext)}let $;if(!O(S))R.input=p.clone(S);else{const W=await g.get(S,x);$=W.documentUrl,R.input=W.document,W.contextUrl&&(R.remoteContext={"@context":W.contextUrl},B.push(R.remoteContext))}"base"in x||(x.base=$||"");let P=f(x);for(const W of B)P=await e({activeCtx:P,localCtx:W,options:x});let X=await a({activeCtx:P,element:R.input,options:x});return j(X)&&"@graph"in X&&Object.keys(X).length===1?X=X["@graph"]:X===null&&(X=[]),w(X)||(X=[X]),X},g.flatten=async function(S,x,R){if(arguments.length<1)return new TypeError("Could not flatten, too few arguments.");typeof x=="function"?x=null:x=x||null,R=Q(R,{base:O(S)?S:"",contextResolver:new y({sharedCache:G})});const B=await g.expand(S,R),$=b(B);return x===null?$:(R.graph=!0,R.skipExpansion=!0,await g.compact($,x,R))},g.frame=async function(S,x,R){if(arguments.length<2)throw new TypeError("Could not frame, too few arguments.");if(R=Q(R,{base:O(S)?S:"",embed:"@once",explicit:!1,requireAll:!1,omitDefault:!1,bnodesToClear:[],contextResolver:new y({sharedCache:G})}),O(x)){const C=await g.get(x,R);if(x=C.document,C.contextUrl){let Z=x["@context"];Z?w(Z)?Z.push(C.contextUrl):Z=[Z,C.contextUrl]:Z=C.contextUrl,x["@context"]=Z}}const B=x?x["@context"]||{}:{},$=await g.processContext(f(R),B,R);R.hasOwnProperty("omitGraph")||(R.omitGraph=s($,1.1)),R.hasOwnProperty("pruneBlankNodeIdentifiers")||(R.pruneBlankNodeIdentifiers=s($,1.1));const P=await g.expand(S,R),X={...R};X.isFrame=!0,X.keepFreeFloatingNodes=!0;const W=await g.expand(x,X),z=Object.keys(x).map(C=>T($,C,{vocab:!0}));X.merged=!z.includes("@graph"),X.is11=s($,1.1);const K=d(P,W,X);X.graph=!R.omitGraph,X.skipExpansion=!0,X.link={},X.framing=!0;let Y=await g.compact(K,B,X);return X.link={},Y=l(Y,X),Y},g.link=async function(S,x,R){const B={};return x&&(B["@context"]=x),B["@embed"]="@link",g.frame(S,B,R)},g.normalize=g.canonize=async function(S,x){if(arguments.length<1)throw new TypeError("Could not canonize, too few arguments.");if(x=Q(x,{base:O(S)?S:null,algorithm:"URDNA2015",skipExpansion:!1,safe:!0,contextResolver:new y({sharedCache:G})}),"inputFormat"in x){if(x.inputFormat!=="application/n-quads"&&x.inputFormat!=="application/nquads")throw new i("Unknown canonicalization input format.","jsonld.CanonizeError");const $=n.parse(S);return v.canonize($,x)}const R={...x};delete R.format,R.produceGeneralizedRdf=!1;const B=await g.toRDF(S,R);return v.canonize(B,x)},g.fromRDF=async function(S,x){if(arguments.length<1)throw new TypeError("Could not convert from RDF, too few arguments.");x=Q(x,{format:O(S)?"application/n-quads":void 0});const{format:R}=x;let{rdfParser:B}=x;if(R){if(B=B||V[R],!B)throw new i("Unknown input format.","jsonld.UnknownFormat",{format:R})}else B=()=>S;const $=await B(S);return I($,x)},g.toRDF=async function(S,x){if(arguments.length<1)throw new TypeError("Could not convert to RDF, too few arguments.");x=Q(x,{base:O(S)?S:"",skipExpansion:!1,contextResolver:new y({sharedCache:G})});let R;x.skipExpansion?R=S:R=await g.expand(S,x);const B=D(R,x);if(x.format){if(x.format==="application/n-quads"||x.format==="application/nquads")return n.serialize(B);throw new i("Unknown output format.","jsonld.UnknownFormat",{format:x.format})}return B},g.createNodeMap=async function(S,x){if(arguments.length<1)throw new TypeError("Could not create node map, too few arguments.");x=Q(x,{base:O(S)?S:"",contextResolver:new y({sharedCache:G})});const R=await g.expand(S,x);return N(R,x)},g.merge=async function(S,x,R){if(arguments.length<1)throw new TypeError("Could not merge, too few arguments.");if(!w(S))throw new TypeError('Could not merge, "docs" must be an array.');typeof x=="function"?x=null:x=x||null,R=Q(R,{contextResolver:new y({sharedCache:G})});const B=await Promise.all(S.map(C=>{const Z={...R};return g.expand(C,Z)}));let $=!0;"mergeNodes"in R&&($=R.mergeNodes);const P=R.issuer||new k("_:b"),X={"@default":{}};for(let C=0;C<B.length;++C){const Z=p.relabelBlankNodes(B[C],{issuer:new k("_:b"+C+"-")}),le=$||C===0?X:{"@default":{}};if(u(Z,le,"@default",P),le!==X)for(const ce in le){const pe=le[ce];if(!(ce in X)){X[ce]=pe;continue}const rt=X[ce];for(const ge in pe)ge in rt||(rt[ge]=pe[ge])}}const W=m(X),z=[],K=Object.keys(W).sort();for(let C=0;C<K.length;++C){const Z=W[K[C]];H(Z)||z.push(Z)}return x===null?z:(R.graph=!0,R.skipExpansion=!0,await g.compact(z,x,R))},Object.defineProperty(g,"documentLoader",{get:()=>g._documentLoader,set:S=>g._documentLoader=S}),g.documentLoader=async S=>{throw new i("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",url:S})},g.get=async function(S,x){let R;typeof x.documentLoader=="function"?R=x.documentLoader:R=g.documentLoader;const B=await R(S);try{if(!B.document)throw new i("No remote document found at the given URL.","jsonld.NullRemoteDocument");O(B.document)&&(B.document=JSON.parse(B.document))}catch($){throw new i("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{code:"loading document failed",cause:$,remoteDoc:B})}return B},g.processContext=async function(S,x,R){return R=Q(R,{base:"",contextResolver:new y({sharedCache:G})}),x===null?f(R):(x=p.clone(x),j(x)&&"@context"in x||(x={"@context":x}),e({activeCtx:S,localCtx:x,options:R}))},g.getContextValue=ae().getContextValue,g.documentLoaders={},g.useDocumentLoader=function(S){if(!(S in g.documentLoaders))throw new i('Unknown document loader type: "'+S+'"',"jsonld.UnknownDocumentLoader",{type:S});g.documentLoader=g.documentLoaders[S].apply(g,Array.prototype.slice.call(arguments,1))},g.registerRDFParser=function(S,x){V[S]=x},g.unregisterRDFParser=function(S){delete V[S]},g.registerRDFParser("application/n-quads",n.parse),g.registerRDFParser("application/nquads",n.parse),g.url=ie(),g.logEventHandler=J,g.logWarningEventHandler=M,g.safeEventHandler=E,g.setDefaultEventHandler=h,g.strictEventHandler=o,g.unhandledEventHandler=A,g.util=p,Object.assign(g,p),g.promises=g,g.RequestQueue=zt(),g.JsonLdProcessor=yn()(g),r.setupGlobals(g),r.setupDocumentLoaders(g);function Q(S,{documentLoader:x=g.documentLoader,...R}){if(S&&"compactionMap"in S)throw new i('"compactionMap" not supported.',"jsonld.OptionsError");if(S&&"expansionMap"in S)throw new i('"expansionMap" not supported.',"jsonld.OptionsError");return Object.assign({},{documentLoader:x},R,S,{eventHandler:F({options:S})})}return g},q=function(){return L(function(){return q()})};return L(q),Ye=q,Ye}var vn=mn();const ue=Xt(vn);async function bn(v){const r=[];for await(const p of v)r.push(p);return r}class se extends Wt.Readable{constructor(r,{baseIRI:p,compact:y,context:k={},encoding:i="object",flatten:t,frame:n,prettyPrint:a,skipContext:b}={}){super({objectMode:!0,read:()=>{}}),this.compact=y,this.context=k,this.encoding=i,this.flatten=t,this.frame=n,this.prettyPrint=a,this.skipContext=b,p&&(this.context["@base"]=p.value||p.toString()),r.on("prefix",(I,D)=>{this.context[I]||(this.context[I]=D.value)}),this.handleData(r)}async handleData(r){try{const p=(await bn(r)).map(se.toJsonldQuad),y=await ue.fromRDF(p),k=await this.transform(y,this.options);this.push(k),this.push(null)}catch(p){this.emit("error",p)}}async transform(r){return this.compact&&(r=await ue.compact(r,this.context)),this.flatten&&(r=await ue.flatten(r,this.context)),this.frame&&(r=await ue.frame(r,this.context)),this.skipContext&&r["@context"]&&delete r["@context"],this.encoding==="string"?this.prettyPrint?JSON.stringify(r,null,2):JSON.stringify(r):r}static toJsonldQuad(r){return{subject:se.toJsonldTerm(r.subject),predicate:se.toJsonldTerm(r.predicate),object:se.toJsonldTerm(r.object),graph:se.toJsonldTerm(r.graph)}}static toJsonldTerm(r){return r.termType==="BlankNode"?{termType:"BlankNode",value:`_:${r.value}`}:r}}class kn extends Qt{constructor(r){super(se,r)}}export{kn as default};
